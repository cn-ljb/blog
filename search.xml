<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-流程控制]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 流程控制语句if语句基本用法同Java 唯一不同点，Kotlin中没有三目运算符（a==xxx?b:c），取而代之的是if表达式 //Java String result = num % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;; //Kotlin val result = if (num % 2 ==0 ) &quot;偶数&quot; else &quot;奇数&quot; 注：if表达式是支持块级代码的，最后返回值由块级代码最后一行代码决定 val result = if (num % 2 == 0) { println(&quot;哈哈哈哈&quot;) &quot;偶数&quot; } else { println(&quot;啦啦啦啦&quot;) &quot;奇数&quot; } 所以，这样写也是没问题的。 When语句貌似是个新东西，其实是Java中switch语句的替代品 val num = 3 when(num){ 1 -&gt; println(&quot;num=1&quot;) 2 -&gt; println(&quot;num=2&quot;) 3 -&gt; println(&quot;num=3&quot;) 4,5,6 -&gt; println(&quot;num = 4 or 5 or 6&quot;) else -&gt; println(&quot;不认识这个数&quot;) } 乍一看，跟Java的switch语句的确没什么区别，只是换了一层皮。 那when到底强在哪？它可以作为表达式，我们把上面的代码改一改 val num = 3 val result = when (num) { 1 -&gt; &quot;num=1&quot; 2 -&gt; &quot;num=2&quot; 3 -&gt; &quot;num=3&quot; 4, 5, 6 -&gt; &quot;num = 4 or 5 or 6&quot; else -&gt; &quot;不认识这个数&quot; } println(result) 可以看到when语句是直接支持返回数据的。 这里要注意当when作为表达式时，一般是要求必须要有else来处理未知情况，但如果你的代码能显示的表明你已经考虑到了所有情况，else也是可以不写的。 当然它和if表达式一样支持块级代码，返回最后一行代码的值。 for循环Kotlin简化了for循环的使用，也就是说，你不用再顽固的写（i=0；i&lt;size;i++）这种东西了。 //获取item for (item: Int in arr) { println(item) } //获取索引 for (index in arr.indices) { println(arr[index]) } //即获取对象，又获取索引 for ((index, item) in arr.withIndex()) { println(&quot;$index :: $item&quot;) } 并且只要数据类型是支持迭代器的，那么都支持这种for循环形式 while 以及 do…while同Java一样 continue、break 以及 return基本使用方法同Java没有变 但是Kotlin支持标签跳转了，怎么玩呢？ 假设有一个三位数组arr[3][3][3]，每个大纬度里只存一个获奖数，需要我们拿程序找到它们，传统的java代码肯定是暴力循环，找到一个数后加标记，一层层跳回，直到返回最外层进行下一次循环，从而提高效率。然而Kotlin有了标签就不用这么麻烦了： var arr = arrayOf( arrayOf(arrayOf(1, 2, 3), arrayOf(1, 88, 3), arrayOf(1, 2, 3)), arrayOf(arrayOf(1, 2, 3), arrayOf(1, 2, 3), arrayOf(1, 88, 3)), arrayOf(arrayOf(1, 88, 3), arrayOf(1, 2, 3), arrayOf(1, 2, 3)) ) loop@ for (item in arr) { for (item2 in item) { for (item3 in item2) { if (item3 == 88) { println(&quot;找到了：$item3&quot;) continue@loop } } } } 代码会输出3次“找到了88”，无论是continue还是break他们的语义是不变的 continue会跳转到标签所在位置的下一次循环 break会结束掉标签所在位置的循环 上面的代码用break实现，只需要把loop@标签放到第二层循环即可。 return呢？return支持标签返回吗？ 答案肯定是支持的，return多半在函数跳转中搭配标签使用，在函数篇章里我们再进行详细讲解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Package]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Package%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs Package命名规则（同Java） 由小写字母、下划线、数字组成，必须由小写字母或者下划线开头 行业规范，同Java，例如：com.baidu.xxx 与Java不同 1、Kotlin中包名可以和实际的文件夹不一致 2、没有指定包名，属于没有名字的默认包上 3、如果有重名包可以使用 as 关键字设置别名 1、Kotlin中包名可以和实际的文件夹不一致这条很好理解，我们知道Java中包名和实际的文件目录是保持一致，如果不一致，编译器会报错并提醒你修改包名或者移动到正确的包下。那么在Kotlin中就没有这么严格的限制，包名和实际的物理地址是可以不一致的。 a包下，存在一个Java文件和Kotlin文件，如果我们手动将文件的package修改为 com.ljb.blogs.packages.b Java文件通不过编译，需要你修改包名或者移动到正确的包下 而Kotlin，编译器会友善的给个提醒找不到实际目录，当然你可以选择忽视 （注：虽然可以包名与目录不一致，但开发者们了解下即好，以前该怎么写还是怎么写） 2、没有指定包名，属于没有名字的默认包上这一条其实也好理解，Kotlin不声明包行吗？答案是行的 /** * 这是一个没有指定包名的Kotlin类 */ class DefaultKotlin{ fun tell(){ println(&quot;我是没有定义包名的DefaultKotlin&quot;) } } 上面这个DefaultKotlin类，把他放到任意包下是不会报错的，即便它没有指定包。 如何使用它呢？跟Java一样，通过import的关键字直接导入即可 package com.ljb.blogs.packages.b //包名和实际的文件目录可以不同 import DefaultKotlin fun main(args: Array&lt;String&gt;) { val def = DefaultKotlin() def.tell() } 3、如果有重名包可以使用 as 关键字设置别名在Java中，如果你要同时使用类名相同，包名不同的两个类，你必须明确的指定出你使用的是哪个包下的类（以包名.类名的形式声明，至少申明其中一个）。 我们在c包，和d包下都定义了Person的Java类 c包下： package com.ljb.blogs.packages.c; public class Person { public void tell(){ System.out.println(&quot;我来自c包&quot;); } } d包下： package com.ljb.blogs.packages.d; public class Person { public void tell(){ System.out.println(&quot;我来自d包&quot;); } } 那么Java中是这样使用： package com.ljb.blogs.packages.a; //包名和实际的文件目录必须相同 import com.ljb.blogs.packages.c.Person; /** * Package Java测试类 */ public class PackageJava { public static void main(String[] args){ //两个同名类，至少你得写一个完成包名的类来进行区分 Person c = new Person(); com.ljb.blogs.packages.d.Person d = new com.ljb.blogs.packages.d.Person(); c.tell(); d.tell(); } } 首先，Java的这种形式Kotlin也是支持的。 其次，Kotlin提供了一种更好的解决方案，让代码看起来更优雅，使用as关键字为包设置别名 package com.ljb.blogs.packages.b //包名和实际的文件目录可以不同 import com.ljb.blogs.packages.c.Person as CPerson //设置别名 import com.ljb.blogs.packages.d.Person as DPerson /** * Package Kotlin测试类 */ fun main(args: Array&lt;String&gt;) { val c = CPerson() val d = DPerson() c.tell() d.tell() } 细心的朋友可能已经发现，我们直接通过Kotlin代码，造了两个Java类的对象（Person），是的，你没猜错，Kotlin可以直接调用Java代码。 其他细节前面提到了improt关键字，跟Java一样都用于导入包，那么java中会默认导入java.lang包，Kotlin又导入哪些包呢？ Kotlin默认导入的包： – kotlin.* – kotlin.annotation.* – kotlin.collections.* – kotlin.comparisons.* (since 1.1) – kotlin.io.* – kotlin.ranges.* – kotlin.sequences.* – kotlin.text.* 根据平台的不同，导入的平台包： JVM: —- java.lang.* —- kotlin.jvm.* JS: —- kotlin.js.* 这些包都分别是什么，有什么用呢？其实看名字我们也能猜出部分包的功能（笔者暂时也没具体的研究这些包的功能，先一笔带过）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Class类]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Class%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 类的定义Kotlin中的类也是使用class关键字定义 但整个类结构与Java有所不同：Kotlin中类的定义主要由三部分组成：类名、类头、类主体。 // 类名 类头 class Person(var name: String) { //...类主体 } 一、类名同Java紧跟class关键字之后，空格隔开 二、类头两部分组成： 成员属性 主构造函数 代码示例： class Person(var name: String) { init { println(&quot;属性已被初始化：$name&quot;) println(&quot;主构造额外操作&quot;) } } name是Person类的一个成员属性，小括号()是Person类的主构造方法。也就是说Kotlin中在创建Person类对象时，必须传入name属性值，并且会自动为其初始化，帮我们做了类似Java里this.name = name的操作。 如果我们的主构造除了初始化属性之外，还有别的代码操作，需要把这些操作放到init()函数中，Kotlin的主构造函数在初始化属性之后，会调用该函数。 调用： Person(&quot;Jack&quot;) 输出： 属性已被初始化：Jack 主构造额外操作 三、类主体类主体部分类似于Java（大括号里的东西），但也有所不同，前面的主构造额外函数init()也属于类主体区域内。 类主体可以包含： 构造函数和初始代码块 成员属性 成员函数 内部类 伴生对象 对象声明 1、构造函数除之前的主构造函数和init()函数外，Kotlin也支持多构造函数，其它的构造函数称为二级构造函数 constructor (name: String, age: Int) : this(name) { this.age = age } 这里，Kotlin定义二级构造函数与Java不同： 仅需constructor关键字修饰，不需要函数名 所有的二级构造必须先调用（代理）主构造，主构造执行完后，会执行二级构造中的代码 所以我们仅在二级构造中初始化了age属性，name属性已由之前的主构造初始化。 如果我们没有定义构造函数（主\二级），JVM虚拟机依旧会为我们提供一个无参构造函数，这和Java一样；但是，如果我们的主构造参数设置了默认值，Jvm虚拟机也会为我们提供一个无参构造。 //主构造存在默认参数，JVM依旧会提供一个无参构造 class Person(var name: String = &quot;无名&quot;) { //... ｝ 所以我们可以使用默认值直接创建Person对象 val wuMing = Person() （注：虽然我们已经创建过很多次对象了，但还是提下Kotlin创建对象是不需要new关键字的） 2、成员属性首先概念上是同Java的成员变量一样的，我们还是单独来说说它的区别和特点 Kotlin支持可变属性和只读属性，什么意思呢？类似于Java中常量和变量的概念 val关键字：只读属性，初始化后，只能访问，不能赋值 var关键字：可变属性，可读可写 getter()\setter() 讲到属性，不能少了JavaBean里的getter()\setter()方法，虽然Java的IDE基本都提供了自动生成代码的快捷选项，但Kotlin将其再一步简化 Kotlin中如果属性是var可变属性，那么默认就提供getter()\setter()函数，val则提供getter()函数 如果我们需要覆写这些getter()\setter()方法只需遵循以下格式： var &lt;propertyName&gt;: &lt;PropertyType&gt; [ = &lt;property_initializer&gt; ] &lt;getter&gt; &lt;setter&gt; 我们尝试修改age属性的getter()方法，不同年龄段，返回不同的数字： var age: Int = 0 get() { if (field &lt; 16) { return 0 } else if (field in 16..30) { return 1 } else return 2 } 调用： val per = Person(&quot;Jack&quot;, 10) println(per.age) //输出0 等等，getter()里的field是什么？备用字段 为什么我们不直接比较age而是用field关键字呢？ 因为在Kotlin中规定，如果直接使用属性名，那么就相当于调用它的getter()函数，所以如果我们在getter函数里直接使用age属性，那么这将是一个无限的递归，JVM自然会抛出 栈溢出。 为了解决这个问题Kotlin在getter()和setter()函数中为我们提供了这个备用字段field 3、成员函数在函数章节提到过，无论是定义，使用，作用域都同Java，暂一笔带过。 4、内部类Kotlin中对于内部类的定义有所不同，在Kotlin中内部类除了必须定义在类的内部外，还必须通过inner关键字修饰，否则它只是个嵌套类。 探讨内部类和嵌套类各自的特点： A是外部类，B是A的嵌套类，C是A的内部类，我们尝试互相访问对方的属性以及函数。 外部类访问嵌套类以及内部类中的资源，我们在A类中添加tell()函数测试： 以上代码中可以得出结论：外部类是无法直接访问嵌套类或者内部类中的任何资源 那么嵌套类能访问外部类资源吗？我们给嵌套类也加上tell()函数 很显然嵌套类是不能直接调用外部类资源以及内部类资源 再来看看内部类： Kotlin中的内部类跟Java一样是可以直接访问外部类资源，但不能访问嵌套类资源 最后，嵌套类、外部类是如何创建对象的: //嵌套类创建对象 val b = A.B() //内部类创建对象 val c =A().C() 嵌套类创建对象，需要指定外部类前缀；而内部类创建对象则需要通过外部类对象来创建 细心的朋友可能已经发现这两种书写格式在Java中很眼熟，内部类的创建格式与Java相同就不说了，这个嵌套类与Java的（static）静态内部类创建语法是一样的。 如果真如我们猜想的那样，Java中的静态内部类，可以访问直接外部类中static修饰的全局变量；Kotlin中的嵌套类我们不妨测试一下。（Kotlin中的全局变量通过伴生对象定义，这个之后会讲，先知道它就是全局变量即可） 我们发现嵌套类可以调用该变量 所以可以得出：Kotlin中的嵌套类的使用场景是类似与Java中的静态内部类的使用场景。 5、伴生对象前面也提到了Kotlin中是没有static关键字的，但是总得有东西来替代它，那么它就是伴生对象。 从名字来看它貌似是随着类一起出生的，它和Java中static的定义也很相似（当类加载时static修饰的属性和方法就直接加载到内存中）。 使用起来也和Java中是一样的，可以直接通过类名调用，还有伴生对象只能使用伴生对象中的属性及方法，就如同static修饰的方法只能调用static修饰的属性和方法一样。 6、对象声明与表达式单例设计模式大家一定再熟悉不过，如果在Java中，肯定首要是创建一个类，然后私有化构造方法等等，Kotlin中提供了更简便的实现方案。你不是仅需一个对象吗，那么干嘛要创建类，直接创建一个对象不是更好。 Kotlin中支持直接创建对象，称为：对象声明 ，使用object关键字修饰。 我们在之前的Person类中声明一个obj对象 那么这个对象对于Person来说就像一个全局的只读变量一样 当然你完全可以不用写在类的内部，只是要知道类的主体里可以写对象声明的 对象表达式又是什么？ Java中的匿名内部类，想必做android开发的同学再熟悉不过，那么Kotlin中的匿名内部类就叫做对象表达式。 既然类似Java中的匿名内部类，那么使用场景肯定也是类似的了。 这段代码想必大家都很熟悉，为Button设置点击事件的回调，用Java代码实现最直接的方法便是创建个匿名内部类对象，那么我们来看看Kotlin的对象表达式 我只能说实在是不能再像了（与Java匿名内部类相比）。 唯一的区别就在于，对象表达式可以直接访问局部作用域里的变量，不需要像java那样final修饰才行。 四、数据类最后再讲讲一种特殊的类：数据类 前面属性时，提到了JavaBean的概念，提供getter()和setter()函数，除了这两个函数之外equals()、toString()等也是几个常用函数，那么Kotlin中为了开发方便，直接提供data关键字来修饰这些数据类。 使用data修饰的类，除了之前var\val提供的setter()\getter()函数之外，还默认实现了 equals()/hashCode 函数 toString 格式是 &quot;User(name=john, age=42)&quot; [compontN()] copy() 函数 如果在类中明确声明或从基类继承了这些方法，编译器不会自动生成。 为确保这些生成代码的一致性，并实现有意义的行为，数据类要满足下面的要求： 主构造函数应该至少有一个参数； 主构造函数的所有参数必须标注为 val 或者 var ； 数据类不能是 abstract，open，sealed，或者 inner ； 在 JVM 中如果构造函数是无参的，则所有的属性必须有默认的值。 例如： data class Data(var data1: String, var data2: String)]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJava背压]]></title>
    <url>%2F2019%2F05%2F17%2FRxJava%E8%83%8C%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[RxJava1背压（Backpressure）背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。 异步环境下 不是操作符，是一种策略 如何解决？主动拉取 通过reques(n) ，需本身支持背压策略 例如： Observable.range() //支持 Observable.interval() //不支持 对于本身就不支持背压的Observable，可以根据实际业务情况使用以下方法来缓解该问题： sample 这个操作符简单理解就是每隔X时间发送里最近那个事件，其他的事件浪费掉； buffer 这个操作符简单理解就是把X时间内的事件打包发送; onBackpressurebuffer 把observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常); onBackpressureDrop 将observable发送的事件抛弃掉，直到subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。 注：onBackpressurebuffer，onBackpressureDrop可以响应下游观察者的request(n)方法了，也就是说，使用了这两种操作符，可以让原本不支持背压的Observable“支持”背压了。 如何区分Observable是否支持背压？rxjava1中没有确切的方法可以确切的方法进行区分，这也是rxjava1中的设计缺陷 RxJava2解决背压问题rxjava2源码层面上重新设计了架构，用于解决背压。 Flowable 支持背压 Observable 不支持背压 各自都有自己的一套几乎相同操作符，但不能混用。如果你有意识的使用流控，那么就用 Flowable ，否则就用 Obserable。 但他们之间支持想换转换 Flowable -&gt; Obserable , Obserable -&gt; Flowable.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo目录和常用命令]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo%E7%9B%AE%E5%BD%95%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[目录介绍 node_modules npm 文件缓存目录 scaffolds 文夹件下存放的是文章、页面模版 scource 文夹件下存放的是我们的资源文件 themes 文件下存放的是我们的主题文件 .gitignore git 忽略文件，设置提交文件时，哪些文件不提交 _config.yml 站点配置文件 package.json 站点版本，站点依赖文件 yarn.lock yarn.lock 文件由 Yarn 自动创建，并且完全通过 Yarn 进行操作。 常用命令$ hexo generate (hexo g) 生成静态文件 $ hexo server (hexo s) 启动本地服务 $ hexo deploy (hexo d) 提交到远程仓库 $ hexo new page &quot;xx&quot;(hexo n page) 创建页面 $ hexo new &quot;xx&quot; (hexo n &quot;&quot;) 创建文章 $ hexo d -g 生成静态并提交到远程仓库 $ hexo s -g 生成静态文件并启动本地预览 $ hexo clean 清除本地 public 文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

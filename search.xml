<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法之美-09排序（一）]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-09%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[常见的排序算法常见的排序算法有很多，例如： 冒泡排序 插入排序 快速排序 选择排序 归并排序 计数排序 桶排序 … 疑问：这么多排序，开发中怎么选择？它们各自有什么特点？ 排序算法的对比方法要想解决上面的疑问，就需要知道每种排序背后的原理，从而比较出什么样的排序适合什么样的场景。 在开始比较之前，对于排序算法来说一般都比较以下几个方面： 1、时间复杂度： 列举出排序算法的最好、最坏、平均时间复杂度，并且知道发生最好、最坏情况下数据状态。 2、空间复杂度： 排序过程中是否需要开辟新的内存空间。我们把排序过程中无需开辟新内存空间的算法，统称为原地排序；反之称为非原地排序。 3、常量阶、系数阶、低阶： 在复杂度分析篇章我们说过，大O表示法舍去常量阶、系数阶、低阶以最高阶作为当前算法的时间复杂度。但在比较排序算法时，同量级的数据条件下两种算法的复杂度有可能是一样的，这时候就需要把低阶考虑进来进行比较。 4、判断次数、位移次数： 顾名思义，排序算法中数据大小判断、交互位移的执行次数。 5、稳定性： 数据中如果存在等值数据，算法排完序后能否保证等值数据的先后顺序不发生改变。 冒泡排序了解完排序算法有哪些比较维度后，开始学习第一个排序算法：冒泡排序。 思路：从第一个元素开始，依次比较两个相邻数据大小，前者大于后者就进行交换操作，每一轮循环确定一个最大值存放到数据最右端，n轮循环后数据就由小到大排序完成。 代码实现： public static int[] sortBubbleSort(int[] arr) { if (arr.length &lt;= 1) return arr; for (int i = 0; i &lt; arr.length; i++) { // 循环轮数 boolean hasSort = false; for (int j = 0; j &lt; arr.length - i - 1; j++) { //每一轮确定一个最大数 if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; hasSort = true; } } if(!hasSort) break; //当某一轮已经无交换操作就无需再排序 } return arr; } 测试： int[] arr = new int[]{2, 1, 8, 6, 7, 0, 4, 3, 9, 5}; printArr(sortBubbleSort(arr)); 输出： 0 1 2 3 4 5 6 7 8 9 时间复杂度：O(n²) 最好时间复杂度O(n)：数据本身就有序，轮询一轮后退出循环； 最坏时间复杂度O(n²)：倒序，两层嵌套循环，内循环执行(n)*(n-1)次，舍去系数：n²； 平均时间复杂度O(n²)： 在数据结构与算法之美 - 02复杂度分析(二)篇章提到过，如果数据源的改变会导致算法执行效率不同，就需要把每一种情况发生的概率一起考虑在内，从而计算加权平均时间复杂度。 显然冒泡排序，随着数据源的不同，内循环的执行次数是不固定的，可能执行到n-x次内循环后数据就有序，从而break出去。我们很难将所有情况的概率考虑进去，或者说这个求解过程很复杂。这时候我对于排序算法的平价时间复杂度我们引入一个新的概念：“有序度、逆序度、满序度”。 有序度、逆序度、满序度我们还是以例子的形式来说明什么是有序度、逆序度、满序度： 1 3 2 4 上面是一组已经有序的数据源 它的有序度是：5 它的逆序度是：1 它的满序度也是：6 什么意思呢？ 有序度： 数据源中，当下标i&lt;j，且满足arr[i]&lt;=arr[j]的两个数称为有序对 ，这组数中有序对个数的总和称为这组数的有序度。 逆序度： 与有序度相反，当下标i&lt;j，且满足arr[i]&gt;arr[j]的两个数称为 逆序对 ，这组数中逆序对个数的总和称为这组数的逆序度。 满序度： 有序度与逆序度的和，也就是所有对的总和，称为满序度。 上面这个例子中： n=4 i=0时 j++ 得到 13(有序对) 12(有序对) 14（有序对） 有序3对 逆序0对 共3对 i=1时 j++ 得到 32(逆序对) 34(有序对) 有序1对 逆序1对 共2对 i=2时 j++ 得到 34(有序对) 有序1对 逆序0对 共1对 可以看到总对数的累加过程是一个等差数列，我们套如等差数列求和公式反向推导出满序度公式： 满序度 = 3 + 2 + 1 = 3(3+1)/2 = 6 =&gt; (n-1)n/2 =&gt; n(n-1)/2 有了这个公式，无论n的量级是多大，我们都可以求出它的满序度。 有序度 = 3+1+1 = 5 逆序度 = 满序度 - 有序度 = 6-5 = 1 回过头来看冒泡排序，内层循环中的比较交换操作就是一次将逆序对变为有序对过程，无论怎么优化，交换操作总次数都是固定的（有多少逆序对就交换多少次）。 交换总次数 = 逆序度 = n(n-1)/2 - 初始数据的有序度。 我们开始计算冒泡排序的平均时间复杂度：最坏情况下，完全倒序，有序度为0，需要n(n-1)/2次交换操作；最好情况下，已有序，有序度为n(n-1)/2，交换操作为0；我们取一个中间值作为平均交换次数=(n(n-1)/2+0)/2=n(n-1)/4 ，及平均时间复杂度为O(n²) 空间复杂度：O(1)整个算法过程没有开辟新的内存空间。 稳定性：稳定冒泡排序中只有前者大于后者才会进行交换操作，相等的情况下不进行交换，所以冒泡排序是稳定的排序算法。 插入排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美-08递归]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-08%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[什么是递归？斐波那契数列在讲解递归前，还是聊聊经典的斐波那契数列。 1, 1, 2, 3, 5, 8, 13, 21, 34, ... 这个数列从第3项开始，每一项都等于前两项之和。 求解数列中第n个数是多少？ 分析： n=1 -&gt; 1 n=2 -&gt; 1 n=3 -&gt; 1+1 = 2 n=4 -&gt; 2+1 = 3 n=5 -&gt; 3+2 = 5 假设f(n)为求解函数，那么可以得到以下推倒公式： f(1)=1 f(2)=1 f(n)=f(n-1)+f(n-2)（n&gt;=3，n∈N*） 用程序实现它： private static int getFSNum(int n) { if (n == 1 || n == 2) return 1; return getFSNum(n-1) + getFSNum(n-2); } 测试： System.out.println(getFSNum(1) + &quot;&quot;); System.out.println(getFSNum(2) + &quot;&quot;); System.out.println(getFSNum(3) + &quot;&quot;); System.out.println(getFSNum(4) + &quot;&quot;); System.out.println(getFSNum(5) + &quot;&quot;); 输出： 1 1 2 3 5 上面这个求解过程是一个典型递归算法实现，那究竟什么是递归？ 递归的概念递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如回溯、DFS 深度优先搜索等 递归算法的三要素 1、一个问题的解可以拆解为一个或多个子问题的解 2、这个问题解题思路与拆解后的子问题解题思路完全一致 3、必须存在终止条件 只有满足以上三点的解题思路才能使用递归算法。 拿上面斐波那契数列的解题思路来说： 1、f(n) 问题可以拆解为 f(n-1)、f(n-2)问题 2、无论是f(n)还是子问题f(n-1)、f(n-2)问题，他们的求解思路是一样的 3、当n=2或者n==1时，结束“递”，开始“归” 如何判断问题是否适合递归算法虽然我们知道了递归的三要素，但实际工作中我们很难一眼看出问题是否满足三要素，在这种情况下直接编写递归代码很容易出错，而且为了找到错误，你可能脑子里或者debug形式一步一步去跟踪递归的每一次嵌套调用，相信大多数情况下你还没有摸清出错原因就已经晕了。 其实，就像上面求解斐波那契数列一样，我们尽可能先分析出递推公式，并找到终止条件，最后编写代码。 利用这种思路，试着解下面这个问题： 有n个台阶,每次只能跨1步或者2步，走到第n个台阶有多少种走法？ 分析： n=1 -&gt; 1 -&gt; 1种 n=2 -&gt; 11、2 -&gt; 2种 n=3 -&gt; 111、12、21 -&gt; 3种 n=4 -&gt; 1111、112、121、211、22 -&gt; 5种 假设f(n)为求解函数： n=1时，只有1个解； n=2时，只有2个解； n&gt;2时，分两种情况，这两种情况的总和就是f(n)的解： 当第一次走1步时，就需求剩余n-1个台阶的解f(n-1)； 当第一次走的是2步时，需求剩余n-2个台阶的解f(n-2)。 得到公式： f(1)=1 f(2)=2 f(n)=f(n-1)+f(n-2)（n&gt;2，n∈N*） 有了公式，写代码就简单了： private static int getStepNum(int n) { if (n == 1) return 1; if (n == 2) return 2; return getStepNum(n - 1) + getStepNum(n - 2); } 测试： System.out.println(getStepNum(1) + &quot;&quot;); System.out.println(getStepNum(2) + &quot;&quot;); System.out.println(getStepNum(3) + &quot;&quot;); System.out.println(getStepNum(4) + &quot;&quot;); 输出： 1 2 3 5 递归算法的堆栈溢出问题通过上面的两个例子，发现递归算法写出的代码都很清爽简洁，易于理解。 但实际开发中递归算法很容易导致堆栈溢出，从而有很多人都不推荐写递归算法。比如上面的台阶问题，当我改成5000个台阶时，运行在我的编译器上就抛出了StackOverflowError. System.out.println(getStepNum(5000) + &quot;&quot;); 运行，抛出StackOverflowError异常： Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.ljb.aljs.Text08.getStepNum(Text08.java:29) ... 这又是为什么？ 在“栈的章节-栈的使用场景”有提到函数的调用在内存中是以栈的形式把函数域中的临时变量全部压栈，只有函数调用完毕后才会出栈释放这些资源。而由于递归算法的特殊性，每一次调用都会压入该栈中，层次越深的递归算法所需的栈空间也就越大，然而系统或者JVM虚拟机的函数调用栈一般都不大，从而越深的递归算法越容易堆栈溢出。 如何避免堆栈溢出1、限制递归深度顾名思义，从代码层面上增加递归深度的计数器，当达到指定深度直接停止递归（throw Exception）。 显然这种方法不能根本解决问题，只适用于明确规定计算深度的业务场景。 2、优化重复计算拿上面台阶的例子来说，当要求f(5)=f(4)+f(3)，需要先求f(4)=f(3)+f(2)，可以发现在f(4)中已经计算过f(3)，在f(5)中又要重新计算。 对于递归中这种重复计算的问题，我们可以进行优化,先将已经计算过的解保存起来（例如：散列表），在下次计算时检查是否已经计算过，从而避免重复计算。 优化后的5000个台阶问题，代码如下： private static int getStepNum(int n) { if (n == 1) return 1; if (n == 2) return 2; if (cache.containsKey(n)) { return cache.get(n); } int result = getStepNum(n - 1) + getStepNum(n - 2); cache.put(n, result); return result; } 虽然我们优化了重复计算问题，并且可以计算出5000个台阶的结果了，但是这也仅仅是优化，当n足够大时依旧会堆栈溢出。 3、改为循环语句基本上所有的递归代码都可以改为循环语句。 改写台阶问题： private static int getStepNum(int n) { if (n == 1) return 1; if (n == 2) return 2; int result = 0, pre = 2, prepre = 1; for (int i = 3; i &lt;= n; i++) { result = pre + prepre; prepre = pre; pre = result; } return result; } 这也是为什么有人提出不要使用递归算法的原因，但我个人认为，在明确知道递归深度不高的情况下优先使用递归，往往使用循环改写后的代码不易于阅读和维护，递归写法的代码阅读性要好很多。 小结递归算法是一种简洁高效的代码书写方式，只要问题满足三要素都可以使用递归来解决，在无法确定是否满足三要素的情况下，可以先推导出递推公式后再进行编码。 递归算法虽然简洁高效，但也会带来堆栈溢出、重复计算、函数调用耗时、空间复杂度高等弊端。 注：文中提到debug不要一步一步跟进代码，不是指递归不可以进行debug调试，一般情况下调试递归代码有两种方式：1、在递归过程中对特定数据加判断，在此处打断点；2、输出日志，定位错误数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美-07队列]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-07%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、什么是队列也是一种“操作受限”的线性表结构，只支持数据的添加（入队-enqueue）和删除（出队dequeue）操作，并具备先进先出特性。 使用场景： 资源有限时，例如线程池、数据库连接池、消息池。 二、队列的实现 数组实现 - 顺序队列 链表实现 - 链式队列 定义队列接口： interface Queue&lt;T&gt; { //入队 boolean enqueue(T item); //出队 T dequeue(); //是否为空 boolean isEmpty(); //数据的数量 int size(); } 1、数组实现思路： ① 初始化一个数组用于存储队列数据； ② 定义两个指针head、tail（元素下标）,head用于指向第一个元素位置，fail用于指向最后一个元素位置，两者初始时都指向首元素； ③ 每入队一个数据，tail便向后移一位，指向该元素； ④ 每出队一个数据，返回head数据后，向后移一位，指向下一个元素（先进先出）； ⑤ 当head==tail时，表示队列已清空。 代码实现： class StringArrQueue implements Queue&lt;String&gt; { private String[] arr; private int count; private int maxSize; private int head = 0; private int tail = 0; public StringArrQueue(int initSize) { maxSize = initSize; arr = new String[maxSize]; } @Override public boolean enqueue(String item) { if (tail == maxSize) return false; //队列已满 arr[tail] = item; ++tail; ++count; return true; } @Override public String dequeue() { if (head == tail) return null; //队列已空 String item = arr[head]; ++head; --count; return item; } @Override public boolean isEmpty() { return head == tail; } @Override public int size() { return count; } public void printAll() { int tempHead = head; while (tempHead != tail) { System.out.print(arr[tempHead] + &quot;\t&quot;); ++tempHead; } System.out.println(); } } 测试： //测试数据 public static StringArrQueue getQueueData() { StringArrQueue queue = new StringArrQueue(5); queue.enqueue(&quot;1&quot;); queue.enqueue(&quot;2&quot;); queue.enqueue(&quot;3&quot;); queue.enqueue(&quot;4&quot;); queue.enqueue(&quot;5&quot;); return queue; } //测试代码 StringArrQueue queue = getQueueData(); queue.printAll(); queue.dequeue(); //出队 queue.dequeue(); //出队 queue.dequeue(); //出队 queue.printAll(); 输出： 1 2 3 4 5 4 5 问题上面的代码当队列满后，即便我们有3次出队操作，这时候再入队数据依旧是失败的。 //测试代码 StringArrQueue queue = getQueueData(); queue.printAll(); queue.dequeue(); //出队 queue.dequeue(); //出队 queue.dequeue(); //出队 queue.printAll(); queue.enqueue(&quot;6&quot;); //继续入队 queue.enqueue(&quot;7&quot;); //继续入队 queue.printAll(); 输出： 1 2 3 4 5 4 5 4 5 //入队的6、7失败 原因：因为当tail指针达到尾部后，不会再重新使用之前的内存空间。 解决方案 方案一：出队时，将所有数据向前搬移一位，始终出队下标为0的元素。 方案二：入队时，检查tail指针是否已经直到末尾，并且head前是否还有空闲内存空间，有则触发数据搬移 显然方案一不太可取，每次出队都会触发数据搬移，该方案出队的时间复杂度为：O(n) 继续看方案二，修改入队方法： public boolean enqueue(String item) { if (tail == maxSize) { if (head == 0) { return false; //队列已满 } //数据搬移 for (int i = head; i &lt; tail; i++) { arr[i - head] = arr[i]; } //计算新指针位置 tail -= head; head = 0; } //入队 arr[tail] = item; ++tail; ++count; return true; } 重新运行，输出： 1 2 3 4 5 4 5 4 5 6 7 // 继续入队成功 为什么方案二优于方案一？方案二的入队时间复杂度分析： 最好时间复杂度O(1)： tail没有到达末尾，直接入队 最坏时间复杂度O(n)： tail达到末尾、且head前有内存空间，位移数据n次，再入队 均摊平均时间复杂度（不适用）： 乍一看，好像一次O(n)可以均摊到之前的n次O(1)上，但均摊平均时间复杂度的先天条件需要规律性出现n次O(1)，常量次O(n)，才可以使用该方法。这个例子由于需要依赖出栈函数，才可能触发位移操作，而出栈函数何时调用是不可控的。 加权平均时间复杂度O(n)： 直接插入操作次数：1 满了无法插入操作次数：1 满了可搬移插入操作次数：(n-1)+…+2+1 假设上面3种情况发生概率相同：1+1+(n-1) 计算：f(n) = (1+1+(n-1)+…+2+1) / (1+1+(n-1)) = 2+ n²/2(n+1) = n 虽然，方案二平均时间复杂度是O(n),但存在最好时间复杂度O(1)以及不确定概率性的最坏时间复杂度O(n)，比起方案一的百分百时间复杂度O(n)要好很多。 2、链表实现基于链表的实现，原理同数组实现，head指针指向首元素，tail指针指向尾元素。 思路：与数组实现类似，但无需考虑内存碎片问题。 class StringLinkedQueue implements Queue&lt;String&gt; { private int count; private Node&lt;String&gt; head, tail; @Override public boolean enqueue(String item) { //入队 if (head == null) { head = new Node&lt;&gt;(item, null); tail = head; } else { tail.next = new Node&lt;&gt;(item, null); tail = tail.next; } ++count; return true; } @Override public String dequeue() { if (head == null) return null; //出队 Node&lt;String&gt; item = head; head = head.next; if (head == null) tail = null; --count; return item.data; } @Override public boolean isEmpty() { return head == null; } @Override public int size() { return count; } public void printAll() { Node temp = head; while (temp != null) { System.out.print(temp.data + &quot;\t&quot;); temp = temp.next; } System.out.println(); } } 测试： //测试数据 public static StringLinkedQueue getQueueData() { StringLinkedQueue queue = new StringLinkedQueue(); queue.enqueue(&quot;1&quot;); queue.enqueue(&quot;2&quot;); queue.enqueue(&quot;3&quot;); queue.enqueue(&quot;4&quot;); queue.enqueue(&quot;5&quot;); return queue; } //测试代码 StringLinkedQueue queue = getQueueData(); queue.printAll(); queue.dequeue(); //出队 queue.dequeue(); //出队 queue.dequeue(); //出队 queue.printAll(); queue.enqueue(&quot;6&quot;); //继续入队 queue.enqueue(&quot;7&quot;); //继续入队 queue.printAll(); 输出： 1 2 3 4 5 4 5 4 5 6 7 3、循环队列比起之前的数组和链表实现的队列，循环队列实现就较为复杂，需注意队空和队满的判定条件。 将循环队列和普通数组队列以画图形式表示如下： 思路： 核心思想：计算数组最后一个元素和第一个元素的边界，由于head、tail指针始终是向后移动1位，我们只需要计算head+1、tail+1对maxSize取余的值作为新的head、tail，当达到边界时，取余余数自然为0。 指针计算公式： 入队： tail = (tail+1)%maxSize 出队： head = (head+1)%maxSize 队空条件不变：head == tail 队满条件：head == (tail+1)%maxSize 代码实现： class CircularQueue implements Queue&lt;String&gt; { private String[] arr; private int count; private int maxSize; private int head = 0; private int tail = 0; public CircularQueue(int initSize) { maxSize = initSize; arr = new String[maxSize]; } @Override public boolean enqueue(String item) { if ((tail + 1) % maxSize == head) return false; //入队 arr[tail] = item; tail = (tail + 1) % maxSize; ++count; return true; } @Override public String dequeue() { if (head == tail) return null; //队列已空 String item = arr[head]; head = (head + 1) % maxSize; --count; return item; } @Override public boolean isEmpty() { return head == tail; } @Override public int size() { return count; } public void printAll() { int tempHead = head; while (tempHead != tail) { System.out.print(arr[tempHead] + &quot;\t&quot;); tempHead = (tempHead + 1) % maxSize; } System.out.println(); } } 测试： //测试数据 public static CircularQueue getQueueData() { CircularQueue queue = new CircularQueue(6); queue.enqueue(&quot;1&quot;); queue.enqueue(&quot;2&quot;); queue.enqueue(&quot;3&quot;); queue.enqueue(&quot;4&quot;); queue.enqueue(&quot;5&quot;); queue.enqueue(&quot;6&quot;); return queue; } //测试代码 CircularQueue queue = getQueueData(); queue.printAll(); queue.dequeue(); //出队 queue.dequeue(); //出队 queue.dequeue(); //出队 queue.printAll(); queue.enqueue(&quot;7&quot;); //继续入队 queue.enqueue(&quot;8&quot;); //继续入队 queue.printAll(); 输出： 1 2 3 4 5 //6入栈失败 4 5 4 5 7 8 问题显然，通过循环队列我们优化了入队时间复杂度O(n) -&gt; O(1)，随之又产生一个新的问题，我们实际使用的内存空间总是比初始化大小少1。 原因就在于，我们在入队时，(tail + 1) % maxSize == head队满判断，导致tail指向n-1时，计算得出tail==head，所以无法入队。 解决方案利用count计数变量来判断空队（coun==0）满队（count==maxSize）情况，修改enqueue()、dequeue（）、praintAll()方法如下： public boolean enqueue(String item) { if (count == maxSize) return false; //入队 arr[tail] = item; tail = (tail + 1) % maxSize; ++count; return true; } public String dequeue() { if (count == 0) return null; //队列已空 String item = arr[head]; head = (head + 1) % maxSize; --count; return item; } public void printAll() { int tempHead = head; int tempCount = count; while (tempCount != 0) { String item = arr[tempHead]; System.out.print(item + &quot;\t&quot;); tempHead = (tempHead + 1) % maxSize; --tempCount; } System.out.println(); } 测试： CircularQueue queue = getQueueData(); queue.printAll(); queue.dequeue(); //出队 queue.dequeue(); //出队 queue.dequeue(); //出队 queue.printAll(); queue.enqueue(&quot;7&quot;); //继续入队 queue.enqueue(&quot;8&quot;); //继续入队 queue.enqueue(&quot;9&quot;); //继续入队 queue.enqueue(&quot;10&quot;); //继续入队，空间不足入队失败 queue.printAll(); 输出： 1 2 3 4 5 6 4 5 6 4 5 6 7 8 9 阻塞队列和并发队列// TODO]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美 - 06栈]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-06%E6%A0%88%2F</url>
    <content type="text"><![CDATA[一、什么是栈？一种“操作受限”的线性表结构，只支持数据的添加（入栈-push）和删除(出栈-pop)操作，并具备先进后出，后进先出特性。 栈的实现使用数组、链表都可以实现栈数据结构。数组实现的栈我们称之为顺序栈；链表实现称之为链式栈。 通过栈的概念我们抽象出一个栈最基本的功能接口： interface Stack&lt;T&gt; { //压栈 boolean push(T item); //弹栈 T pop(); //是否为空 boolean isEmpty(); //栈中数据的数量 int size(); //返回栈中最近添加的元素而不删除它 T peek(); } 1、顺序栈实现一个存储字符串的顺序栈： class StringArrayStack implements Stack&lt;String&gt; { private int count; private String[] items; private int maxSize; private String curItem; public StringArrayStack(int maxSize) { this.items = new String[maxSize]; this.maxSize = maxSize; } @Override public boolean push(String item) { if (count == maxSize) return false; items[count] = item; ++count; curItem = item; return true; } @Override public String pop() { if (count == 0) return null; String item = items[count - 1]; items[count - 1] = null; --count; curItem = items[count - 1]; return item; } @Override public boolean isEmpty() { return count == 0; } @Override public int size() { return count; } @Override public String peek() { return curItem; } public void printAll() { for (int i = 0; i &lt; count; i++) { System.out.print(items[i] + &quot;\t&quot;); } System.out.println(); } } 测试： //测试数据 public static StringArrayStack getStackAndData() { StringArrayStack stack = new StringArrayStack(10); stack.push(&quot;1&quot;); stack.push(&quot;2&quot;); stack.push(&quot;3&quot;); stack.push(&quot;4&quot;); stack.push(&quot;5&quot;); stack.push(&quot;6&quot;); stack.push(&quot;7&quot;); stack.push(&quot;8&quot;); stack.push(&quot;9&quot;); stack.push(&quot;10&quot;); return stack; } //测试代码 StringArrayStack stack = getStackAndData(); stack.printAll(); stack.pop(); stack.pop(); stack.peek(); stack.pop(); stack.printAll(); 输出： 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 以上是使用数组实现一个固定大小的栈，一般情况下固定大小的栈就满足我们的业务需求，诺需要动态扩容，只需要在内存不足时扩展一个大小大于原先数组的新数组，将旧数组数据copy进新数组（具体的实现可以查看数组章节ArrayList的原码分析）。 空间复杂度无论是添加还是删除操作，栈始终操作的是栈顶数据，每一个数据操作只占一个内存空间大小，所以空间复杂度为O(1) 时间复杂度在支持动态扩容的情况下： 最好情况是数组大小足够时直接添加，所以最好时间复杂度为O(1)； 最坏情况是需要进行动态扩容，那么每个元素都需要进行位移，所以最坏时间复杂度为O(n)； 这里是个典型适合平摊分析法来计算平均时间复杂度场景，当插入n+1元素时，需要将前n个元素全部位移到新的数组中，我们把这n次位移均摊到它们自身的每次进栈操作中，每次的进栈操作时间复杂度依旧是O(1)，所以均摊时间复杂度为O(1). 其实，使用数组实现的栈，其添加和删除操作的时间复杂度和数组是一样。 2、链式栈这里使用链表实现栈就不写实际的例子了，只要知道每一种数据结构的出现，都表明它在某些特殊领域能发出自己的独特作用。 链表实现的栈在内存方面因为有指针的存在，内存消耗更大，但在某些特殊场景又能为我们带来便利。 因为只需要栈顶添加和删除结点，所以时间复杂度都为O(1)，空间复杂度与顺序栈一样O(1). 二、栈的使用场景以下列举栈数据结构的使用场景 1、函数调用变量存储栈一般情况下，代码都执行在线程中，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。 2、栈在表达式中的使用当我们通过代码来实现一个表达式求值时（例如：1+2*3+4-5），可以使用两个栈分别来存储数字以及操作符。 思路： 利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。 3、浏览器的前进后退功能思路： 利用两个栈，X栈用于存储新打开的页面，Y栈存储后退页面 当点击后退时，将X出栈一个页面，并存入Y栈 当点击前进时，将Y出栈一个页面，并存入X栈 当打开新页面时，入X栈，清空Y栈 三、思考 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？ 答：因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，我们优先考虑栈结构。 2.我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？ 答：JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美 - 05链表（二）]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-05%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链表操作练习这篇主要编写几道单向链表操作练习： 单链表Node class Node { public int data; public Node next; public Node(int data) { this.data = data; } public Node(int data, Node next) { this.data = data; this.next = next; } } 1、单向链表反转 思路： 遍历所有结点，将当前结点的next指针指向前一个结点，操作完成后原尾节点作为反转后的头结点即可。 代码实现： public static Node reverse(Node list) { Node tempNode = list; Node preNode = null; while (tempNode != null) { Node next = tempNode.next; tempNode.next = preNode; preNode = tempNode; tempNode = next; } return preNode; } 测试： //测试数据 public Node getNodeList() { Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = null; return node1; } //测试代码 Node list = getNodeList(); printAll(list); Node reverseList = reverse(list); printAll(reverseList); 输出： 1 2 3 4 5 5 4 3 2 1 2、循环链表检测检查一个链表是否是循环链表 思路： 通过快、慢指针同时遍历链表，快指针步长为2，慢指针步长为1，当快指针追上慢指针就是循环链表，否则快指针遍历到尾节点（next-&gt;null）就非循环链表。 代码实现： public static boolean checkCircle(Node list) { if (list == null) return false; Node fast = list.next; Node slow = list; while (fast != null &amp;&amp; fast.next != null) { if (fast == slow) return true; fast = fast.next.next; slow = slow.next; } return false; } 测试： //测试数据 public Node getNodeList() { Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = node1; return node1; } //测试代码 Node list = getNodeList(); System.out.println(&quot;循环链表：&quot; + checkCircle(list)); 输出： 循环链表：true 3、两个有序的链表合并将两个有序链表，合并成一个有序链表 思路： 1、比较两者头结点、以最小的作为head头结点 2、定义两个指针p,q，分别指向该链表，定义一个临时指针temp指向头结点 3、同时开始遍历这两个链表，如果有一个链表到达尾部，则停止循环 4、循环中，如果p指针取内容小于q，则temp.next-&gt;p，反之temp.next-&gt;q 5、循环结束，temp拼接剩余未遍历的p或者q（两链表程度可能不等） 6、返回第1步时确认的head头结点 代码实现： public static Node mergeSortedLists(Node list1, Node list2) { if (list1 == null) return list2; if (list2 == null) return list1; Node p = list1; Node q = list2; //确认首节点 Node head; if (p.data &lt;= q.data) { head = p; p = p.next; } else { head = q; q = q.next; } //开始排序 Node tempNode = head; while (p != null &amp;&amp; q != null) { if (p.data &lt;= q.data) { tempNode.next = p; p = p.next; } else { tempNode.next = q; q = q.next; } tempNode = tempNode.next; } //确认剩余尾部 if (p == null) { tempNode.next = q; } else { tempNode.next = p; } return head; } 测试： //测试数据 public Node getNodeList() { Node node1 = new Node(1); Node node2 = new Node(3); Node node3 = new Node(5); Node node4 = new Node(7); Node node5 = new Node(9); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = null; return node1; } public Node getNodeList2() { Node node1 = new Node(2); Node node2 = new Node(4); Node node3 = new Node(6); Node node4 = new Node(8); Node node5 = new Node(10); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = null; return node1; } //测试代码 Node list1 = getNodeList(); Node list2 = getNodeList2(); Node mergeNode = mergeSortedLists(list1, list2); printAll(mergeNode); 输出： 1 2 3 4 5 6 7 8 9 10 4、删除链表倒数第 n 个结点 思路： 1、先定义fast指针，指向正数第n个结点； 2、再定义慢指针low执行头结点； 3、快慢指针以步长1开始遍历，当fast快指针达到尾结点时，low指针正好在倒数第n个结点位置； 4、考虑到单链表删除，需要造作前一个结点，所以在第3步遍历前定一个pre结点指向慢指针low的前一结点； 5、当遍历完成有两种情况：第一种，pre指向不为null，low就是要删除的结点，pre则为倒数n-1结点，操作pre结点即可删除low结点；第二种，pre为null,要删除的正好是首结点，将第二个结点作为首节点即可。 代码实现： public static Node deleteLastKth(Node list, int n) { if (list == null || n &lt; 1) return list; Node fast = list; int i = 1; while (fast != null &amp;&amp; i &lt; n) { fast = fast.next; i++; } //不存在倒数第n个结点 if (fast == null) return list; //开始运算，定位倒数n结点 Node slow = list; Node pre = null; while (fast.next != null) { fast = fast.next; pre = slow; slow = slow.next; } if (pre == null) { //倒数n结点正好是首节点 list = list.next; } else { //循环结束，slow就为倒数第n个结点，操作pre结点删除slow结点 pre.next = pre.next.next; } return list; } 测试： //测试数据 public Node getNodeList() { Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = null; return node1; } //测试代码 Node list1 = getNodeList(); Node node = deleteLastKth(list1, 2); printAll(node); 输出： 1 2 3 5 5、求链表的中间结点 思路： 1、定义快慢指针fast、slow2、同时开始遍历，fast步长为2，slow步长为13、当快指针fast达到尾部，slow正好在中心结点 代码实现： public static Node findMiddleNode(Node list) { if (list == null) return null; Node slow = list; Node fast = list; while (fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } 测试： //测试数据 public Node getNodeList() { Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = null; return node1; } //测试代码 Node list1 = getNodeList() printAll(list1); Node middleNode = findMiddleNode(list1); System.out.println(&quot;middleNode：&quot; + middleNode.data); 输出： 1 2 3 4 5 middleNode：3]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美 - 04链表（一）]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-04%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法之美-学习大纲 前篇提到了链表也属于线性表结构。那么可想而知，链表在内存中存储的形式肯定也是类似于一条直线进行延伸的。 从内存图中我们可以看出，链表数据结构的内存分配情况并不是连续，作为线性表结构的关键就在于每个数据节点都是由数据块和“指针”块组成。 数据块 ： 存储真正的数据 指针块 ： 存储下一个节点的内存首地址 例如上图Node1节点中的指针块存储的就是Node2的首地址1003（这里假设一个节点占用1个字节） 单向链表 可以看出单链表的方向是固定的，数据块的指针始终指向下一个节点，当没有下一个节点时，最后一个节点称之为尾节点，它的指针块存储null，表示没有下一个节点；而第一个节点称之为首节点，只要知道首节点，就可以获取到该链表中的任意节点数据。 链表的插入与删除与数组一样，链表也支持插入、删除、查询操作。我们知道数组的插入、删除操作需要大量的数据迁移工作，时间复杂度为：O(n)。而在链表中插入和删除造作就非常简单。 插入操作还是开篇之前的例子，现在需要在Node1和Node2中间插入Node8节点，我们只需要两步： ①修改Node1的指针块存储Node8的首地址； ②再让Node8的指针块存储原Node1指针块地址。 可以看出它的时间复杂度为O(1)。 删除操作同理，删除Node2节点也只需只需两步： ①修改Node1的指针块存储Node3的首地址； ②清空Node2的指针块。 删除操作的时间复杂度也是O(1)。 查询操作有利就有弊，与数组恰恰相反，链表因为不是连续的内存块，就无法通过寻址公式计算每个节点的首地址，所以查询一个节点就必须从首节点挨个查询下去，知道找到位置，即时间复杂度O(n)。 循环链表循环列表是一种特殊单向列表，它的尾节点指针块不在存储的是null，而是首节点的首地址。 这种链表的优点在某些特殊场合处理环型数据更加合适，比如著名的约瑟夫问题。 约瑟夫环N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。 例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。 我们仅针对这个例子来写代码： class Node { public int data; public Node next; public Node(int data) { this.data = data; } } 创建一个Node类，该类的数据块存储人员编号123456，next指向下一个人员节点，我们手动创建出6个人员： Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); Node node6 = new Node(6); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = node6; node6.next = node1; 那么报数时，只要报到4的人，他的下一位就出局，核心算法如下： Node node = node1; System.out.print(&quot;出局：&quot;); while (node != node.next) { for (int i = 1; i &lt; 4; i++) { node = node.next; } //当报数到4时，下一个人员就是出局了 Node outNode = node.next; System.out.print(outNode.data); //报数4的人指向下一个人员的下一个人员 node.next = outNode.next; //定位到下一位的下一位，准备下一轮 node = node.next.next; outNode.next = null; } System.out.println(&quot;\n幸运者：&quot; + node.data); 双向链表和单向链表不同，双向链表有两个指针块，一个和单向链表一样指向下一个节点的next指针，一个是指向上一个节点的pre指针。 有了之前单链表的数据结构认识，双向链表数据结构不难理解，但这样设计又带来什么好处？ 缺点首先，由于每个节点比单向链表都多一个指针块，内存方面的占用肯定是大于单向链表。 优点由于多了一个前驱指针，当出现需要获取前节点需求是，复杂度就仅仅O(1)，而单向链表就不得不重新从首节点遍历，时间复杂度（O2）,这种设计我们称之为：用空间换时间。 关于实际情况中的双链表操作的优点虽然之前我们提到单向链表的删除操作时间复杂度是O(1)，但实际开发中我们删除需求可能会是删除某个节点（Node对象）。这时候，单链表就无法把它的上一个节点和下一个节点直接连接起来（没有前驱指针块），就必须重新遍历链表找到上一个节点，它的时间复杂度就变为了O(n)，而双链表就没这个问题。 同理，当要删除某个具体节点时，单向列表依旧无法获取到上一个节点，无法直接跟新节点连接，所以时间复杂度O(n)；而双向链表依旧是O(1)。 如果链表数据是有序的，那么在查询上虽然两者时间复杂度是O(n)，但实际上双向链表可以支持更快查询。双向链表可以把每次查询到的节点记录下来，当下次查询值大于当前就可以继续向后查询，反之向前查询，从而节省大部分时间。 LinkedHashMap底层就是通过双向链表实现。 双向循环链表这个概念想必不用多说，跟循环链表一样，把首尾相连即可。 它的特性就不多说了，将双向和循环的优缺点结合起来。 链表 VS 数组时间复杂度对比 数组 插入 O(n) 链表 插入 O(1) 数组 删除 O(n) 链表 删除 O(1) 数组 查询 O(1) 链表 查询 O(n) 链表和数组的对比不能局限于时间复杂度。 数组的缺点是内存大小连续且固定，比如内存中剩余100M，但并不是连续的，那么在创建一个100M的数组时就会导致“内存不足（out of memory）”，而链表就可以正常创建。 但正因为数组是连续的内存区域，有利于CPU的缓存机制，可以提前预读到CPU中，提到访问效率；但链表中的数据由于都是单个的内存区，就无法提前预读。并且如果频繁的对链表节点进行插入、删除操作，可能会导致JVM频繁的GC，产生更多的内存碎片。 LRU淘汰算法LRU淘汰算法属于缓存策略一种，一般缓存策略分为三种： 1、先进先出策略 FIFO 2、最少使用策略 LFU 3、最近最少使用策略 LRU 这里我们使用双向链表就可以实现一个最近最少使用策略LRU缓存机制： 我们将缓存数据倒序放入链表中 当读取某个缓存数据时，遍历缓存数据 如果存在，就将该节点在原先位置删除，再插入到首节点 如果不存在 缓存大小充足，就将该数据插入首节点 缓存大小不充足，删除尾节点，再插入首节点 这种设计的缓存策略，由于每次读取都要遍历节点，所以时间复杂度为O(n)。当讲到散列表时，我们可以使用上面同样的思路设计LRU缓存策略，并且将读取缓存的时间复杂度优化到O(1)。 以下为缓存Data类型数据的LRU淘汰算法实现： class Data { public String id; public int data; public Data(String id, int data) { this.id = id; this.data = data; } public void print() { System.out.print(&quot;{id : &apos;&quot; + id + &quot;&apos; , data : &quot; + data + &quot;}&quot;); } } 双向链表： class Node { public Node pre; public Data data; public Node next; public Node(Data data) { this.data = data; } } LruCache实现类： class LruCache { private Node first; private int size; private int maxSize; public LruCache(int maxSize) { this.maxSize = maxSize; } public void add(Data data) { //校验数据是否合法 if (data.id == null) return; //查询节点是否已经缓存 Node tempNode = first; Node last = null; while (tempNode != null) { if (tempNode.data.id.equals(data.id)) { if (tempNode.pre != null) { tempNode.pre.next = tempNode.next; } //已缓存，移动到头部位置 tempNode.next = first; first.pre = tempNode; first = tempNode; first.pre = null; return; } else { //未缓存，记录尾节点 if (tempNode.next != null) { tempNode = tempNode.next; } else { last = tempNode; break; } } } //超过初始化大小，删除尾节点 if (size + 1 &gt; maxSize &amp;&amp; last != null) { last.pre.next = null; size--; } //添加新节点到头部 Node newNode = new Node(data); newNode.pre = null; newNode.next = first; if (first != null) { first.pre = newNode; } first = newNode; size++; } public Data get(String id) { Node tempNode = first; while (tempNode != null) { if (tempNode.data.id.equals(id)) { return tempNode.data; } tempNode = tempNode.next; } return null; } public void print() { Node tempNode = first; while (tempNode != null) { System.out.print(tempNode.data.data + &quot;\t&quot;); tempNode = tempNode.next; } System.out.println(); } } 测试：创建一个大小为3的缓存空间，并存入一组数据，查看存储情况 LruCache cache = new LruCache(3); Data data1 = new Data(&quot;1&quot;, 111); Data data2 = new Data(&quot;2&quot;, 222); Data data3 = new Data(&quot;3&quot;, 333); Data data4 = new Data(&quot;4&quot;, 444); cache.add(data1); cache.add(data2); cache.add(data3); cache.add(data4); cache.add(data2); cache.print(); Data data = cache.get(&quot;3&quot;); data.print(); 输出： 222 444 333 {id : &apos;3&apos; , data : 333}]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美 - 03数组]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-03%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数据结构与算法之美-学习大纲 什么数组？ 数组是一种 线性表 数据结构。它用一组 连续的内存空间，来存储一组 相同类型 的数据。 线性表数据排成一条线一样的数据结构。除了数组，还有链表、队列、栈等都是线性表结构。 而与之对立的概念称为非线性表，属于这类数据结构的有：树、图、堆等。 连续的内存空间和相同类型相同类型：很好理解，存储的数据都属于某一种类。 连续的内存空间： 拿上面大小为10整型数组内存图举例，假设分配的内存地址从1000开始，那么第一个元素内存地址就是1000-1003的位置（整型数据占4个字节），总共有10个元素，最后的结束位置就是1039,这就是连续的内存。 高效的查询试想想，已知数组a的首地址是1000，我们怎么最快的读取到a[1]内存中的数据？ 是不是 1000 + 4 = 1004 的内存地址？ a[2]、a[3]呢？ a[2]内存地址 = 1000 + 2 * 4 = 1008 a[3]内存地址 = 1000 + 3 * 4 = 1012 从而我们发现规律，并得出寻址公式： a[i]_address = base_address + i * data_type_size 有了这个公式我们便能快捷的读写对应的数组元素，这种特性称之为随机访问 。 这里还有一个小知识，数组的下标从0开始是为了更方便的套入到寻址公式中计算，如果从1开始每次寻址时需要多1步减法操作，数组作为最常用的数据结构，多少会有点性能消耗。 有了寻址公式，通过下标查询某元素的时间复杂度为：O(1) 低效删除和插入为什么会导致低效？又有哪些改进方法呢？ 插入操作假设数组的长度为n，我们想把某个数插入到数组k小标所在位置，那么为了腾出k的位置，我们需要把k-n的所有元素顺序往后移动一位。 试着分析下上面这段操作的时间复杂度： 如果要插入的元素下标为最后1个元素，需要移动元素为：0 插入下标为倒数第1元素，需要移动元素：1 插入下标为倒数第3元素，需要移动元素：2 … 插入小标为第1个元素，需要移动元素：n 插入元素到任意位置的概率是1/n f(n) = 1+2+3+…+n / n = n/2*(n+1) / n = n(n+1) / 2n T(n) = O((n+1) / 2) = O(n) 通过以上分析，得出插入有序数组操作的时间复杂度如下： 最好情况时间复杂度为：O(1) 最坏情况时间复杂度为：O(n) 平均情况时间复杂度为：O(n) 有没有别的方法？ 如果插入前提需保证数组的数据是有序的，那么就必须按照上面的方法来搬移k之后的元素。 但如果仅是将某个元素插入到指定位置，而不考虑元素中原有的顺序，我们可以先将原k元素放到数组末尾，再将新元素插入到k的位置，如图： 利用上面这种方式，在特定场景中，它的时间复杂度为：O(1) 删除操作与插入类似，要删除数组中k的元素，就需要把k-n都向前移动1位，从而保证数组的内存连续性，那么删除末尾元素移动为0，删除第1个元素移动为n，所以删除操作的时间复杂度和插入是一样的： 最好情况时间复杂度为：O(1) 最坏情况时间复杂度为：O(n) 平均情况时间复杂度为：O(n) 当然在某些特定的场景下，我们也可以对删除操作进行优化，例如我们有a,b,c,d,e,f,g,h组成的一个数组，我们依次删除a，b,c时，位移操作就要进行3n遍；如果现在的场景并不要求数组中实时的连续性，我们就可以分别将a、b、c先标记成删除状态，当数组没有多余的存储空间时，再做统一的实际删除。 这样就大大减少了每次删除元素所需的位移操作。 这种标记删除状态的思想，也是JVM GC垃圾回收机制的核心思想。 ArrayList谈到数组，使用Java语言就必离不开ArrayList，ArrayList是Java语言为我们提供的通过数组实现的数据存储容器，使用容器的好处就在于它为开发者已经封装好了增、删、查等算法，并提供一些其它方便又常用的特性，例如动态扩容。 ArrayList的动态扩容我们都知道数组在创建时，它的内存大小就固定了，例如下面这个arr数组的内存大小为3，当我们给第4个元素赋值并运行时时就会抛出ArrayIndexOutOfBoundsException. int[] arr = new int[3]; arr[0] = 1; arr[1] = 2; arr[2] = 3; arr[3] = 4; //运行时抛出异常 当你使用ArrayList时，就无此烦恼： ArrayList list = new ArrayList(3); list.add(1); list.add(2); list.add(3); list.add(4); //可以正常添加 通过ArryList源码我们可以发现其原理，首先ArrayList为我们创建了一个大小为3的数组（以下代码为ArrayList源码）： public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; //初始化一个我们传入大小为3的数组 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); } } 其次在添加元素时，如果数组大小不够用，扩容一个新的1.5倍的数组，然后再将原数组copy到新数组中，最后将元素加入： public boolean add(E e) { ensureCapacityInternal(size + 1); // 这个方法会去调用扩容相关方法 elementData[size++] = e; // 最后加入元素 return true; } // 扩容核心方法 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //扩容1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); //copy一个新的大小 } 使用数组，还是使用ArrayList？乍一看，ArrayList相比数组要好用的多，我们无需关心数组的大小是否公用，也无需知道增删操作的算法复诊度是多少。 是的，大多数情况下我们使用ArrayList就能满足我们的需求； 但当你的要存储一组基本数据类型数据，且对性能要求较高时，可以优先考虑使用数组，ArrayList在存储基本数据类型数据时，需要进行装箱、拆箱操作，会有一定的性能损耗。 当数据大小已知，无删、插、扩容需求时，也可考虑使用数组。 JVM GC标记清除算法前文提到JVM GC标记清除算法这里简单介绍下。 基本思想：标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。 在标记阶段，首先通过根节点做搜索，标记所有从根节点开始的可达对象，未被标记的对象就是未被引用的垃圾对象，在清除阶段清除所有未被标记的对象。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美 - 02复杂度分析(二)]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-02%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法之美-学习大纲 上一节，学习了什么是大O复杂度分析、有哪些复杂度分析技巧、什么是时间复杂度、什么是空间复杂度以及有哪些常见的复杂度（O(1)、O(logn)、O(n)、O(nlogn)）。 如果你对以上提到的内容还不了解，请点击这里：数据结构与算法之美 - 复杂度分析(一) 最好、最坏情况时间复杂度上例子： int find(int[] arr, int x) { int position = -1; int n = arr.length; for (int i = 0; i &lt; n; i++) { if (arr[i] == x) { position = i; break; } } return position; } 显然，这是一个从数组arr中查询x的索引position，如果不存在返回-1。我们尝试使用之前的方法先标注出每行代码的单位时间： int position = -1; // 1 * unitTime int n = arr.length; // 1 * unitTime for (int i = 0; i &lt; n; i++) { // ??? if (arr[i] == x) { // ??? position = i; // ??? break; } } 发现循环体中的代码执行次数是不固定的，比如当x在数组索引0的位置，那么它的时间复杂度是O(1)，当x不存在数组中那么就是O(n)，这时候就产生了两个极端情况下的时间复杂度，我们称之为：最好情况时间复杂度、最坏情况时间复杂度。 find()方法的最好情况时间复杂度为O(1)，最坏情况时间复杂度为O(n)。 （加权）平均情况时间复杂度既然有最好和最坏，那么在这两者之间肯定有很多我们叫不上名的情况，我们怎么更好的表示这个算法的复杂度呢？ 随着x所在的arr数组索引位子不同需要的循环次数也就不同，我们尝试把所有的循环次数累加出来，并除以总的可能性，来计算下平均某种可能性下的循环次数。 循环总次数累加：1+2+3+…+n+n （多+n是因为当x不在数组里依旧需要循环n遍） 可能出现的情况累加：n+1 (+1是x不在数组中也是一种情况) 计算: f(n) = (1+2+3+…+n+n) / (n+1) 1+2+3+…+n 中学数学里的等差数列还有印象吗？我们套入等差数列求和公式： 得到：1+2+3+…+n+n = n/2*(n+1)+n = n(n+3)/2 则： f(n) = n(n+3)/2 / (n+1) = (n²+3n) / (2n+2) 套用大O复杂度表示法得到： T(n) = O((n²+n) / n) = O(n+1) = O(n) 通过求平均数并且套用大O复杂度表示法，我们的到这个例子的平均情况时间复杂度为：O(n)。 然而，这个平均情况时间复杂度我们在推算过程中并不完全正确，我们忘了什么呢？ 试想一下，我们总循环次数除以n+1表示的是所有情况出现的概率一致时的平均时间复杂度，那每种情况出现的概率真的都一致吗？ 这里就需要引入一点高中数学概率论的知识了： 简单解释下，虽然我们已经统计出来会出现n+1中情况，但每种情况出现的概率其实是不同的。x存在或者不存在arr数组中的概率简单看作1/2；x存在arr数组中时，存在arr数组索引的某个位置的概率又是1/n；那么x存在arr数组中的某个索引的概率其实是1/2n。 那么我们把概率重新套入到之前的推算过程中： x在arr数组中情况循环次数加入概率：(1+2+3+…+n)/2n = (n+1)/4 x不在arr数组中情况循环次数加入概率：n/2 套入f(n)= (n+1)/4 + n/2 = (3n+1)/4 大O复杂度表示法：T(n) = O((3n+1)/4)=O(n) 这个平均值，在概率论中称之为加权平均值，这种时间复杂度我们称之为加权平均时间复杂度。 显然这个例子的加权平均时间复杂度也是O(n)。 总结下，一般同一段代码，在不同的情况下出现多种不同的时间复杂度，这时候我们会用最好时间复杂度、最坏时间复杂度、（加权）平均时间复杂度来表示。 均摊时间复杂度到这里复杂度分析的内容基本总结完了，而现在要学的内容可以看作为平均时间复杂度的一种特殊情况。 class IntArr { private final int DEF_SIZE = 10; private int[] arr = new int[DEF_SIZE]; private int len = DEF_SIZE; private int index = 0; public void add(int num) { if (index &gt;= len) { //空间不足，扩充数组大小，比之前多一半 int newLen = len + len / 2; int[] newArr = new int[newLen]; for (int i = 0; i &lt; len; i++) { newArr[i] = arr[i]; } arr = newArr; len = newLen; } arr[index] = num; index++; } ... } 上面我创建了一个整形数组容器，它的好处是可以自动扩展空间大小，我们尝试计算出它的时间复杂度。 通过代码，我们看到： 没当数组大小不够用时，会扩展之前大小的一半，并且进行遍历copy 开始分析： 第一遍： 当 index &lt; len 时，时间复杂度是 O(1) 当 index &gt;= len 时，时间复杂度是O（n） 扩展后第二遍： 当 index &lt; len 时，时间复杂度是 O(1) 当 index &gt;= len 时，时间复杂度是O（n） 扩展后第三遍： … 一眼看出，它的最好时间复杂度是O(1)，最坏时间复杂度是O(n)，那它的平均时间复杂度是多少呢？ 假设当前数组长度是n，填加一个数进入数组的所需时间分两种情况：当前添加位置小于n，那么所需单位时间为1，这种情况下的总时间就是1+1+1+…+1=n；当添加的位置大于等于n时，所需的时间就为n。 总时间就为：1+1+1+…+1+n = 2n 无论是小于n里的每一次情况还是大于等于n时的情况，它们的发生的概率都是1/(n+1) f(n) = 2n/(n+1） = 1 则最终加权平均时间复杂度为O(1) 这个例子我们也通过概率的形式算出了加权平均时间复杂度，当然这个算法是肯定没问题的。但是，其实有更简单的方法算出它的平均时间复杂度： 可以看到上面的每一遍分析规律，都是出现n次O(1)复杂度后，再出现一次O(n)复杂度，我们假设把O(n)复杂度分为n份，每份的时间单位也就是1，把这些拆分的时间单位平摊到前面的n次O(1)中，尽管前面的n次O(1)复诊度时间单位变成了2，但它的时间复杂度依旧是O(1)。 上面这种分析方法，称为平摊分析法，分析出的时间复杂度称为均摊时间复杂度。 对于这种随着数据的不断改变，出现了某种固定规律的算法，我们可以尝试使用平摊分析法快速得到均摊时间复杂度。 小结到此，复杂度分析就全部学完了，这节学习了最好情况时间复杂度、最坏情况时间复杂、(加权)平均时间复杂度、均摊时间复杂度。 要想学好数据结构和算法，那么复杂度分析就是重中之重，学会复杂度分析就相当于学会了一半。学好复杂度分析还是那句话： 复杂度分析并不难，贵在勤于练习！ 铭记于心！]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美 - 01复杂度分析(一)]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-01%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法之美-学习大纲 前面章节提到：为了选择正确的数据结构与算法，这就需要考量代码的执行效率和资源消耗这两个方面。 如何考量执行效率（时间）、资源消耗（空间）呢？ 事后分析法首先，性能测试、时间统计、内存监控等方案可以直观的让我们看到时间与空间的使用情况，并且得到确切值。 但以上方案都有以下局限性： 1、测试结果依赖测试环境 随着测试环境的硬件不同，得到的测试结果差距也就越大。举个例子：i9 cpu 和 i3 cpu 执行同一段代码，很明显i9所用的时间远远要小i3。 2、测试结果随数据规模的变化可能产出完全不一的结果 还是举个例子，我们在做排序的时候，数据规模足够大快速排序优于插入排序；但如果数据规模很小，插入排序反倒会比快速排序要快。 3、后滞性 我们只有在进行完性能测试后才能知道现在的算法是否优于之前的算法。 所以有没有一种方法可以在不需要测试数据的情况下，就能粗略估算出当前算法的执行效率、资源消耗？ 大O复杂度表示法我们把算法的执行效率，粗略的比作代码的执行时间。 举一个例子，尝试以“肉眼”的形式来估算出它的执行时间： 想必这段代码大家并不陌生，求1+2+3+…+n的和。 我们假设每一行代码的运行时间是一样的，记作unitTime，那么上面这段代码的每行代码时间表示为： int sum = 0; // 1 * unitTime int i = 1; // 1 * unitTime for (; i &lt;= n; i++) { // n * unitTime sum += i; // n * unitTime } 总的时间加起来就为： T(n) = (2+2n) * unitTime T(n)表示执行代码的总时间； 2+2n，首先是一个表达式，表示n与代码执行次数的趋势，我们记作f(n)。 那么上面的例子可以写作f(n)=2+2n. 这里我们引入一个概念，当n取值趋近于无穷大时，f(n)的常数项和系数项相比于n的取值规模对整个函数的影响可以忽略不计，我们仅关注函数的最大阶，则得到：f(n)=n. 这种概念称之为“大O复杂度表示法”，有专门的公式来表示： 上面求和的例子以大O复杂度表示法表示为:T(n) = O(2n+2) = O(n) 时间复杂度还是以上面求和代码为例，我们最后得到的O(n)就是它的大O时间复杂度。所有我们总结出以下概念：大O时间复杂度并不表示代码的实际执行时间，而是代码执行时间与数据规模发生增长的变化趋势，叫作 渐进时间复杂度，简称时间复杂度。 知道了什么是时间复杂度，那么怎么进行时间复杂度分析，或者说复杂度分析有哪些技巧？ 复杂度分析 1、执行次数最多的那段代码n的量级 还记得大O复杂度表示法的概念吗？重点的知识我们再记一遍，当n取值趋近于无穷大时，f(n)的常数项和系数项相比于n的取值规模对整个函数的影响可以忽略不计，我们仅关注函数的最大阶。 那么这个概念套到代码里，分析一个算法时,我们只需关注被执行次数最多的那段代码。这段代码执行次数n的量级，就是这个算法的时间复杂度。 int sum = 0; // 1 * unitTime int i = 1; // 1 * unitTime for (; i &lt;= n; i++) { // n * unitTime sum += i; // n * unitTime } 还记的这段代码吧，这里for循环我们粗略估计为执行了n次（不要在意i&lt;=n执行了n+1，我们只在意对整个趋势影响最大的n），那么n的量级就是n，则时间复杂度就为： T(n)=O(n) 再举个例子： public int fun2(int n) { int sum = 0; // 1 * unitTime int i = 1; // 1 * unitTime int j; // 1 * unitTime for (; i &lt;= n; i++) { // n * unitTime j = 1; // n * unitTime for (; j &lt;= n; j++) { // n² * unitTime sum = sum + i * j; // n² * unitTime } } return sum; } 跟之前的例子一样，我们当然可以得到 f(n)=3+2n+2n² ， 但是我们现在知道了时间复杂度等于执行次数最多的那段代码n的量级，所以一眼就能看出这个例子的时间复杂度是 T(n) = O(n²） 2、加法法则：总复杂度等于量级最大的那段代码复杂度 有时候，代码中出现多个时间复杂度的情况，例如： public int fun3(int n) { //1、 int sum1 = 0; int i = 1; for (; i &lt;= 100; i++) { sum1 += i; } //2、 int sum2 = 0; int j = 1; for (; j &lt;= n; j++) { sum2 += j; } //3、 int sum3 = 0; int k = 1; int l; for (; k &lt;= n; k++) { l = 1; for (; l &lt;= n; l++) { sum3 = sum3 + i * j; } } return sum1 + sum2 + sum3; } 很明显，这里有3段代码的时间复杂度，我们分别记为：T1(n) = O(1)、T2(n) = O(n)、T3(n) = O(n²). 后面这两个时间复杂度不用解释了（看之前例子），至于第一个为什么是O(1)而不是O(100)，在这里说明下，前面的概念也提到了时间复杂度不是指代码的实际执行时间或者次数，而是指两者间的增长趋势，在这里面无论n如何增长，第一段代码的执行次数是不会受到影响的，对于这种常量阶的时间复杂度，我们统统记为：O(1). 回归正题，上面这三段代码都有自己的时间复杂度，那整个算法的时间复杂度怎么算呢？- 取最大阶 那么上面这个例子的时间复杂度就为：T(n) = T1(n)+T2(n)+T3(n) = max(O(1),O(n),O(n²)) = O(n²) 3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 根据法则的描述可以看出这个法则适用于嵌套代码，那什么是嵌套代码？ 其实fun2()的例子就是嵌套代码，只是我们一眼就可以看出第二层for循环里的代码执行次数为n²次，很多情况下算法并不能直观的让我们看到它的最大阶，例如我把这个例子的代码稍微改一下： public int fun4(int n) { int sum = 0; int i = 1; for (; i &lt;= n; i++) { sum = sum + fun5(n, i); // n * unitTime } return sum; } public int fun5(int n, int i) { int sum = 0; int j = 1; for (; j &lt;= n; j++) { sum = sum + j * i; // n * unitTime } return sum; } 我只是把第二层循环放到了新的方法中，由于n在两个代码片段中，我们很难一眼看到n的最大阶，此时我们只需把嵌套内外代码都看成独立的代码片段，并得出各自的时间复杂度：T1(n) = O(n)、T2(n) = O(n)，再作它们的乘积即可： T(n) = T1(n) T2(n) = O(n) O(n) = O(n*n) = O(n²) 以上就是常用的3种复杂度分析的方法，至于实际问题中使用哪个方法，只有多练习，熟能生巧。 常见的时间复杂度虽然代码千差万别，但实际上常见的复杂度量级并不对。通过上面的例子，我们已经了解了3种常见的时间复杂度： 常量阶 O(1) 线性阶 O(n) 次方阶 O(n²) 既然我们嵌套两层n循环时间复杂度是O(n²)，三层则为O(n³),同理无论多少次方我们统称为次方阶。 除了这3种，还有以下常见时间复杂度： 对数阶 O(logn) 对数的概念还记得？（高中概念），比如：3² = 9 以对数的形式表示就是 2 = log39（输入不了小3），读作：2为以3为底，9的对数；那么x = logaN，读作：x为以a为底N的对数。 知道了对数的基本概念后，什么样的代码是对数阶呢？ public void fun6(int n) { int i = 1; while (i &lt;= n) { i = i * 2; // ? * unitTime } } 也是一段很常见的代码，怎么证明它是对数阶呢？ 很明显我们只要求出循环里的i = i * 2 的执行次数与n之间的关系，就能算出它的时间复杂度 我们可以尝试给n带入一个数，比如n=4时，循环次数与i值变化如下： i=1 i = 1 * 2 = 2 i=2 i = 2 * 2 = 4 i=4 i = 4 * 2 = 8 n=10时： i=1 i = 1 * 2 = 2 i=2 i = 2 * 2 = 4 i=4 i = 4 * 2 = 8 i=8 i = 8 * 2 = 16 我们会发现i的取值范围是个等比数列：2 2² 2³ … 2的x次方 ，当2的x次方 &gt; N 时停止循环 ， 那么我们就可以得到：f(n) = log2n. 通过换底公式我们可以继续推算： f(n) = log2n = logn/log2 =&gt; logn 我们把对数形式的时间复杂度的底数都换为以10为底，那么就会得到logn除以某个对数常数 ，而大O复杂度表示法中我们忽略常数部分的影响，最终所有的对数复杂度都为 T(n) = O(logn) 线性对数阶 O(nlogn) 如果前面的对数阶你已经了解，那么我在对数阶的外层再加一层for循环遍历n次，利用乘法法则它的时间复杂度便是：T(n) = O(n) * O(logn) = O(nlogn)，后续的归并排序，快速排序复杂度都是O(nlogn)，到对应章节时再细说。 指数阶(2的n次方) &amp; 阶乘阶(n!) 这两个一般称之为非多项式量级，其它的称之为多项式量级。我们只需要知道随着n的增大，非多项式量级的算法执行时间会急剧增加，求解结果的时间会无限增加。所以非多项式是非常低效的算法，实际开发中需劲量避免出现这种代码。 O(m+n) 这里在说一种特殊的时间复杂度表示形式，之前的示例代码都很理想，一个算法中只有一个数据n在影响代码的时间复杂度，但往往我们代码可能是这样的： public int fun7(int n, int m) { int sum1 = 0; int i = 1; for (; i &lt; n; i++) { sum1 = sum1 + i; } int sum2 = 0; int j = 1; for (; i &lt; m; j++) { sum2 = sum2 + j; } return sum1 + sum2; } 出现了两个量级：T1(n) = O(n)、T2(m) = O(m)，这种情况下我们不能利用加法法则省略掉一个低阶量级，所以它的时间复杂度就为：T(n) = T1(n) + T2（m） = O(n)+O(m) = O(n+m) 但如果是嵌套关系，乘法法则依旧是可用的，记作：O(m*n) 空间复杂度前面长篇大论讲解时间复杂度，其实只要你能牢牢掌握它，那么空间复杂度学起来就非常简单了，因为无论是空间复杂度分析，还是常见的空间复杂度，它们的分析方式都是类似的。 重温下时间复杂度的概念：时间复杂度并不表示代码的实际执行时间，而是代码执行时间与数据规模发生增长的变化趋势； 类比一下，总结出空间复杂度的概念：空间复杂度也并不是实际的内存存储大小，而是内存空间与数据规模增长的变化趋势。 写个简单例子就明白了： public void fun8(int n) { int[] arr = new int[n]; // n * unitSize int i = 0; // 1 * unitSize for (; i &lt; n; i++) { arr[i] = i; } } 分析方法跟之前是大致相同的，我们只关注内存趋势发生改变最大的代码，以它的阶量作为控件复杂度，即：S(n)=O(n). 常见的空间复杂度常见的空间复杂度一般有： O(1) O(n) O(n²) 像对数阶，线性对数阶空间复杂度基本都用不到。 空间复杂度的内容就不再一一举例了，只要多加练习，真正理解了时间复杂度，空间复杂度自然迎刃而解。 小结复杂度也叫渐进复杂度，可分为时间复杂度和空间复杂度，使用大O复杂度表示法来表示。可以粗略的认为，越高阶的复杂度算法，性能越低。常见的复杂度由低到高：O(1)、O(logn)、O(n)、O(nlogn)、O(n²)，我们要学的数据结构与算法基本都在这几个复杂度里。 复杂度分析并不难，贵在勤于练习！]]></content>
  </entry>
  <entry>
    <title><![CDATA[PageStateLayout-Android页面管理组件]]></title>
    <url>%2F2019%2F05%2F18%2FPageStateLayout-Android%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一款简单的页面切换布局组件 https://github.com/cn-ljb/PageStateLayout 集成方式 1、Project的build.gradle文件添加如下代码： allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } } } 2、主Module的build.gradle添加依赖： //page layout implementation &apos;com.github.cn-ljb:PageStateLayout:1.0.0&apos; 代码示例 layout.xml中使用 &lt;com.ljb.page.PageStateLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/page_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; app:page_empty=&quot;@layout/layout_page_empty&quot; app:page_error=&quot;@layout/layout_page_error&quot; app:page_load=&quot;@layout/layout_page_loading&quot; app:page_content=&quot;@layout/layout_page_content&quot;/&gt; 或者code中使用 page_layout.setLoadView(R.layout.layout_page_loading) page_layout.setEmptyView(R.layout.layout_page_empty) page_layout.setErrorView(R.layout.layout_page_error) page_layout.setContentView(R.layout.layout_page_content) 代码切换布局 page_layout.setPage(pageState) pageState取值 PageState.STATE_SUCCESS -&gt; 成功页面 PageState.STATE_EMPTY -&gt; 空页面 PageState.STATE_ERROR -&gt; 错误页面 PageState.STATE_LOADING -&gt; 加载页面 演示]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Kotlin MVP 架构搭建]]></title>
    <url>%2F2019%2F05%2F18%2FAndroid%20Kotlin-MVP%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Github地址：https://github.com/cn-ljb/mvp-kotlin -&gt; Star 一下o(∩_∩)o MVPKotlin 快捷、高效、低耦合的Android MVP架构，支持Java、Kotlin混编。 扫码体验： 集成方式 1、Project的build.gradle文件添加如下代码： allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } } } 2、主Module的build.gradle添加依赖： //mvp core implementation &apos;com.github.cn-ljb:kotlin-mvp-lib:1.0.0&apos; //net lib implementation &apos;com.github.cn-ljb:netlib:1.0.0&apos; //dao lib implementation &apos;com.github.cn-ljb:daolib:1.0.0&apos; lib源码：kotlin-mvp-lib、net-lib、dao-lib 概述 为什么要使用MVP架构？ 通常一般的Android项目结构，我们会在Activity\Fragment中编写大量代码，例如：网络请求、数据填充、页面切换等等，这种项目结构宏观的称之为MVC。 MVC：我们可以把数据源（网络请求、IO…）看作Model层，xml等布局文件看作View层，Activity\Fragment看作Controller层。但在android中xml能力太薄弱了，以至于Activity做了很多本不属于它的工作。 MVP：在MVP架构中Model层与MVC一样作为数据源，不过将Activity\Fragment都看作为View层的一部分负责数据的展示和填充，将Model层与View层的关联操作交给了Presenter层。 该项目架构 特点： 1、V层仅由Activity和Fragmen组成，且仅负责View交互和数据填充工作； 2、M层完全与V层隔离，P层作为V层与M层的桥梁，承担中间人角色（V通过P获取M数据）； 3、V层与P层相互持有，通过Constract限制两者的访问域降低耦合； 4、P层通过Factory产出M层Protocol的接口引用降低耦合； 5、Factory产出的M层Protocol是可复用，且内存安全的。 代码示例 Contract接口 内部定义IView、IPresenter小接口分别继承IViewContract、IPresenterContract. interface LoginContract { interface IView : IViewContract { ... } interface IPresenter : IPresenterContract { fun login() ... } } View层 Activity\Fragment继承BaseMvpXxx，在泛型中关联P层约束接口，并实现V层约束接口。 class LoginActivity : BaseMvpActivity&lt;LoginContract.IPresenter&gt;(), LoginContract.IView { override fun registerPresenter() = LoginPresenter::class.java private fun login() { getPresenter().login() } ... } Presenter层 Presenter继承BaseMvpPresenter，在泛型中关联V层约束接口，并实现P层约束接口。 class LoginPresenter : BaseMvpPresenter&lt;LoginContract.IView&gt;(), LoginContract.IPresenter { override fun login() { ... } } 网络请求 1、使用网络库前，需要先进行初始化，建议放到Application中进行； 2、编写HttpProtocol接口； 3、从HttpFactory中产出HttpProtocol实例。 /** * 1、初始化网络库 * @param1: 接口base url * @param2: 公共header * @param3: 公共参数 * @param4: 是否输出日志 * */ HttpConfig.init(HTTP_API_DOMAIN, headerMap, paramMap, isLog) /** * 2、编写HttpProtocol接口 * */ interface IUserHttpProtocol { /** * 通过用户名获取用户信息 * @param userName 用户名 * @return 用户基本信息 * */ @GET(&quot;/users/{userName}&quot;) fun getUserInfoByName(@Path(&quot;userName&quot;) userName: String): Observable&lt;User&gt; ... } /** * 3、从HttpFactory中产出HttpProtocol实例 * */ HttpFactory.getProtocol(IUserHttpProtocol::class.java) .getUserInfoByName(userName) .compose(RxUtils.bindToLifecycle(getMvpView())) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe() 是不是很眼熟？该网络库内部是通过 okhttp + retrofit + rxjava 实现。 数据库操作 1、使用数据库前，需要先进行初始化，建议放到Application中进行； 2、继承BaseTable编写Table类； 3、编写DaoProtocol接口； 4、编写DaoProtocol接口实现类； 5、关联DaoProtocol接口与DaoProtocol接口实现类； 6、从DaoFactory中产出DaoProtocol实例。 /** * 1、初始化数据库 * @param1 数据库OpenHelper辅助类（详见项目代码） * @param2 DaoProtocol关联类 * */ DaoConfig.init(dbHelper, protocolConfig) /** * 2、继承BaseTable编写Table类 * 实现createTableName() 和 createColumns() * Time:2019/4/20 * There is a lot of misery in life **/ class UserTable : BaseTable() { val COLUMN_ID = BaseColumns._ID val COLUMN_USER_ID = &quot;user_id&quot; val COLUMN_AVATAR_URL = &quot;avatar_url&quot; val COLUMN_NAME = &quot;name&quot; ... /** * 返回表名 */ override fun createTableName() = &quot;tb_user&quot; /** * 返回表字段 */ override fun createColumns(): Map&lt;String, String&gt; { val tableColumns = HashMap&lt;String, String&gt;() tableColumns[COLUMN_ID] = &quot;integer primary key autoincrement&quot; tableColumns[COLUMN_USER_ID] = TYPE_TEXT tableColumns[COLUMN_AVATAR_URL] = TYPE_TEXT tableColumns[COLUMN_NAME] = TYPE_TEXT ... return tableColumns } } /** * 3、编写DaoProtocol接口 **/ interface IUserDaoProtocol : IDaoInterface { /** * 保存用户 * */ fun saveUser(table: UserTable, user: User): Observable&lt;Boolean&gt; } /** * 4、编写DaoProtocol接口实现类 **/ class UserDaoProtocol : BaseDaoProtocol(), IUserDaoProtocol { override fun saveUser(table: UserTable, user: User): Observable&lt;Boolean&gt; = createObservable { saveUserImpl(table, user) } private fun saveUserImpl(table: UserTable, user: User): Boolean { ... } } /** * 5、关联DaoProtocol接口与DaoProtocol接口实现类 **/ class ProtocolConfig : IDaoProtocolConfig { @Suppress(&quot;UNCHECKED_CAST&quot;, &quot;IMPLICIT_CAST_TO_ANY&quot;) override fun &lt;T&gt; transformProtocol(clazz: Class&lt;T&gt;) = when (clazz) { IUserDaoProtocol::class.java -&gt; UserDaoProtocol() ... else -&gt; throw IllegalStateException(&quot;not found dao interface object : ${clazz.name}&quot;) } as T } /** * 6、从DaoFactory中产出DaoProtocol实例 **/ DaoFactory.getProtocol(IUserDaoProtocol::class.java) .saveUser(mUserTable, user) .compose(RxUtils.bindToLifecycle(getMvpView())) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe() Kotlin MVP Auto 插件头晕？Kotlin MVP Auto插件帮你统统搞定。 安装插件 操作： File -&gt; Settings -&gt; Plugins -&gt; Kotlin MVP Auto -&gt; install 功能演示 自动生成Contract、View、Presenter Kotlin文件 操作：包目录右键 -&gt; New MVP Kotlin -&gt; 输入模块名称 -&gt; OK 自动生成Contract、View、Presenter Java文件 操作：包目录右键 -&gt; New MVP Java -&gt; 输入模块名称 -&gt; OK 后续功能开发中… 截图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码分析]]></title>
    <url>%2F2019%2F05%2F17%2FEventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[版本 ： org.greenrobot:eventbus:3.1.1 ![EventBus-Publish-Subscribe.png]( https://cn-ljb.github.io/images/EventBus源码分析/EventBus.png) 简介Android或者Java平台下的一款高效的事件总线框架。 特点： 简洁的组件通信机制 发布者、订阅者完全分离 线程安全 内存安全 调用者代码简洁 快捷迅速 包小 经过了100,000,000+App安装量验证 支持优先级 源码分析我们以一个最简单的示例作为分析的突破口（以下代码均以Kotlin编写）。 第1步：编写一个事件类 class MessageEvent(val data: String) 第2步：订阅者 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //1、注册 EventBus.getDefault().register(this) } //2、定义订阅触发方法 @Subscribe(threadMode = ThreadMode.MAIN) fun onMessageEvent(event: MessageEvent) { Log.i(&quot;test&quot;, &quot;MessageEvent事件被触发&quot;) } override fun onDestroy() { super.onDestroy() //3、注销 EventBus.getDefault().unregister(this) } } 第3步：发布者 EventBus.getDefault().post(MessageEvent(&quot;123456&quot;)) 显然第1步没什么好分析的，怎么看它都是一个普普通通的类。 EventBus.getDefault().register(this) 源码而第2步中大致又可以分为三部分：注册、定义触发方法、注销。我们看看注册的源码都执行了哪些逻辑： // EventBus.getDefault().register(this)方法源码 public void register(Object subscriber) { //1 Class&lt;?&gt; subscriberClass = subscriber.getClass(); //2 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) { //3 for (SubscriberMethod subscriberMethod : subscriberMethods) { subscribe(subscriber, subscriberMethod); } } } register()方法内部实现大致可看为3行代码： 1、获取传入subscriber对象的字节码对象 2、通过字节码对象获取到一个List集合 3、遍历这个集合，调用subscribe()方法 ，把当前subscriber和item subscriberMethod以形参形式传入 字节码对象不必多讲，我们看看subscriberMethodFinder.findSubscriberMethods()这个方法返回的集合究竟是什么： List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) { 缓存机制... if (ignoreGeneratedIndex) { subscriberMethods = findUsingReflection(subscriberClass); } else { subscriberMethods = findUsingInfo(subscriberClass); } 缓存机制... return subscriberMethods; } 便于阅读，这里省掉部分不影响核心功能的的代码，重点放到这个if判断上，通过源码的查看ignoreGeneratedIndex我们并没有进行过修改操作，这里走的是默认值false,再看看findUsingInfo()方法做了什么： private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) { //1、 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); //2、 while (findState.clazz != null) { findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) { 缓存机制... } else { findUsingReflectionInSingleClass(findState); } //3、 findState.moveToSuperclass(); } //4、 return getMethodsAndRelease(findState); } 这里又出现了一个新类FindState： static class FindState { final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(); final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;(); final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo; void initForSubscriber(Class&lt;?&gt; subscriberClass) { this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; } ... ｝ 可以看出来FindState是一个容器管理类，貌似存放了一些跟这个订阅者Class字节码对象相关的数据，顺便看下initForSubscriber()方法将我们的订阅者Class对象赋值给了该容器的subscriberClass和class. 再看这里的while循环肯定为true了，if语句我们看else部分，其他部分属于缓存机制，findUsingReflectionInSingleClass()方法如下： private void findUsingReflectionInSingleClass(FindState findState) { //1、 Method[] methods; try { // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); } catch (Throwable th) { // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; } //2、 for (Method method : methods) { int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) { Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) { Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) { Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) { ThreadMode threadMode = subscribeAnnotation.threadMode(); //3、 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); } } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { ... } } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) { ... } } } 首先通过反射获取到了当前订阅者Class中的所有Method对象，接下来遍历这些Method对象，最终把我们编写订阅触发方法的Method找了出来（@Subscribe注解标识的方法），一个订阅者可以有多个订阅触发方法，都将它们存储到findState.subscriberMethods集合里。 让我们findUsingInfo()，至于findState.moveToSuperclass()我们就不看了，这里就是获取当前订阅者Class的superClass通过while再去查询它里面的订阅事件，重走刚刚所分析的逻辑，最后看getMethodsAndRelease(findState)返回了什么东西： private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) { List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); 缓存机制... return subscriberMethods; } 原来就是将findState.subscriberMethods返回了回去，通过一层层的返回最终subscriberMethods返回到了register()方法中，那么register()方法中就剩最后遍历调用的subscribe()方法，看看它都做了什么： private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) { Class&lt;?&gt; eventType = subscriberMethod.eventType; //1、 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) { subscriptions = new CopyOnWriteArrayList&lt;&gt;(); //2、 subscriptionsByEventType.put(eventType, subscriptions); } else { if (subscriptions.contains(newSubscription)) { throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); } } int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) { if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) { //2、 subscriptions.add(i, newSubscription); break; } } List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) { subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); } subscribedEvents.add(eventType); 粘性事件处理... } 这里代码看似很多，大家只需记住1个对象、2个容器即可： 对象：Subscription 存储了注册时传入的订阅者subscriber 和 某个订阅方法（@Subscribe注解标注的方法） 容器1：Map&lt;Class,List&lt; Subscription &gt;&gt; subscriptionsByEventType 存储了某个事件类型（eg:MessageEvent） -&gt; 对应的所有的Subscription（小对象） 容器2：Map&lt;Object, List&lt; Class &gt;&gt; typesBySubscriber 存储了某个订阅者 -&gt; 对应订阅的所有事件类型（eg:MessageEvent…） 到此整个register()的源码已经走了一遍，小结一句话： register()方法，通过反射将订阅者中@Subscribe注解标注的所有方法、订阅对象、订阅事件类型分别存储到了两个容器中。 EventBus.getDefault().unregister(this) 源码想想，register()方法是将订阅者拆解出来存储到不同容器中，那么unregister()用来做什么？那肯定是将当前订阅者相关的存储数据从容器中remove喽： public synchronized void unregister(Object subscriber) { //1、 List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) { //2、 for (Class&lt;?&gt; eventType : subscribedTypes) { unsubscribeByEventType(subscriber, eventType); } typesBySubscriber.remove(subscriber); } else { logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); } } private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) { List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) { int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) { Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) { subscription.active = false; subscriptions.remove(i); i--; size--; } } } } 可以看到先通过容器typesBySubscriber获取到当前订阅者订阅的所有事件类型，并从该容器中清除，再通过unsubscribeByEventType()方法清除subscriptionsByEventType容器中跟这个订阅者相关的数据。 EventBus.getDefault().post() 源码还剩最后一个问题，我们在订阅者中定义的订阅方法（@Subscribe注解标注的）什么时候会被调用？ EventBus.getDefault().post() 从最上面的例子代码，我们也可以看到发布者代码只有一行，说明所有的类在任意地方都可以成为发布者发布事件，从而触发订阅者的订阅方法。其实，订阅者也可以是任意类，只是Android中常见的界面是Activity和Fragment，并且为了保证内存安全所以一定要在销毁的生命周期里调用注销api，只要任意类中在合理的位置进行注册和注销也是可以安全的使用EventBus的。 来看看post()源码吧： public void post(Object event) { //1、 PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) { postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) { throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); } try { //2、 while (!eventQueue.isEmpty()) { postSingleEvent(eventQueue.remove(0), postingState); } } finally { postingState.isPosting = false; postingState.isMainThread = false; } } } 一目了然，将当前要出发的事件类型添加到队列中，在while循环中调用postSingleEvent()方法发布事件： private void postSingleEvent(Object event, PostingThreadState postingState) throws Error { Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) { List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) { Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); } } else { subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); } 可以忽略... } 发现最后都会调用postSingleEventForEventType()方法： private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) { CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) { //1、 subscriptions = subscriptionsByEventType.get(eventClass); } if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) { //2、 for (Subscription subscription : subscriptions) { postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try { //3、 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; } finally { postingState.event = null; postingState.subscription = null; postingState.canceled = false; } if (aborted) { break; } } return true; } return false; } 通过subscriptionsByEventType容器获取到了所有跟当前订阅事件类型关联的Subscription对象集合，遍历调用postToSubscription()方法： private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) { switch (subscription.subscriberMethod.threadMode) { case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) { invokeSubscriber(subscription, event); } else { mainThreadPoster.enqueue(subscription, event); } break; case MAIN_ORDERED: if (mainThreadPoster != null) { mainThreadPoster.enqueue(subscription, event); } else { // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); } break; case BACKGROUND: if (isMainThread) { backgroundPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); } } 该方法主要负责线程调度的过程，我们仅关注invokeSubscriber()即可： void invokeSubscriber(Subscription subscription, Object event) { try { //1、 subscription.subscriberMethod.method.invoke(subscription.subscriber, event); } catch (InvocationTargetException e) { handleSubscriberException(subscription, event, e.getCause()); } catch (IllegalAccessException e) { throw new IllegalStateException(&quot;Unexpected exception&quot;, e); } } 通过我们之前在Subscription对象里保存的method对象和它的订阅者对象，以及当前事件类型对象以反射调用的形式触发了我们在订阅者中编写的订阅方法。 小结通过以上的源码追踪，EventBus的内部实现我们已经有了一个清晰的认识，乘热打铁总结一下： register()方法通过反射将当前订阅者中的订阅方法、订阅类型、订阅者进行了拆解存储到了两个容器中； unregister()方法负责将当前的订阅者数据从那两个容器中移除； post（）方法在容器中找到跟当前订阅事件类型相关联的订阅方法、订阅者，并通过反射进行调用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-优点&缺点]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E6%A7%BD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 这篇不聊具体的知识点，仅聊聊kotlin在开发中好的地方，以及博主自认为不好的地方。 优点1、延迟加载（lazy） 初始化变量的时机被推迟到访问时，有了它真是方便了我们这些不注重内存效率的码农…(lazy具体的实现在委托章节已经进行了详细讲解，不妨点进去看看它是怎么实现的) //仅在被访问时，才会开辟10个元素大小的数组 val arr by lazy { Array(10, { i: Int -&gt; i}) } fun main(args: Array&lt;String&gt;) { arr.map { println(it) } } 仅当你调用数组arr时，该数组才会被初始化出来。 2、getter/setter 首先Kotlin中我们不需要想Java那样手动的添加getter、setter方法了，这些Kotlin已经为我们做好了 3、with()函数简化代码 /* * 通过with语句，可以直接将对象传入，省掉对象的声明 * 使用场景：当对一个变量要进行多次使用，并返回与该变量相关的结果 * */ fun alphabet4(): String { return with(StringBuilder()) { append(&quot;START\n&quot;) for (letter in &apos;A&apos;..&apos;Z&apos;) { append(letter) } append(&quot;\nEND&quot;) toString() } } 4、apply()函数简化代码 /** *apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象 * 使用场景：初始化变量，并对该变量域有操作时 */ fun alphabet5() = StringBuilder().apply { append(&quot;START\n&quot;) for (letter in &apos;A&apos;..&apos;Z&apos;) { append(letter) } append(&quot;\nEND&quot;) }.toString()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-委托]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 委托一、委托类什么是委托类？ 代理设计模式，在Java中实现一个简单的代理模式如下： //抽象功能 public interface Base { void doSome(); } //实际操作类 public class BaseImpl implements Base { @Override public void doSome() { System.out.println(&quot;java do some thing.&quot;); } } //代理类 public class BaseProxy implements Base { private Base impl; public BaseProxy(Base impl) { this.impl = impl; } @Override public void doSome() { impl.doSome(); } } Kotlin在语法上提供by关键字，所以实现以上代码，可以更简洁点： interface Base { fun doSome() } class BaseImpl : Base { override fun doSome() { println(&quot;do some thing...&quot;) } } class BaseProxy(val b: Base) : Base by b 当然，你可以在代理中扩展doSome函数，只需覆写它即可 class BaseProxy(val b: Base) : Base by b{ override fun doSome() { println(&quot;pre&quot;) b.doSome() println(&quot;next&quot;) } } 二、委托属性委托类并不是重点，主要看看委托属性。 什么是委托属性？ 就如同代理设计模式一样 在调用属性或者赋值属性值时，我们希望做些额外操作，Kotlin基本语法如下： val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; by 后面的表达式就是代理，因为get() set() 对应的属性会被 getValue() setValue() 方法代理。属性代理不需要任何接口的实现，但必须要提供 getValues() 函数(如果是 var 还需要 setValue())。 例如： class Person() { var name: String by PrefixName() constructor(name: String) : this() { this.name = name } } class PrefixName { private var proxyName: String = &quot;admin_&quot; operator fun getValue(person: Person, property: KProperty&lt;*&gt;): String { return &quot;admin_$proxyName&quot; } operator fun setValue(person: Person, property: KProperty&lt;*&gt;, s: String) { proxyName = s } } 我们将Person的name属性委托给了PrefixName类，该类提供了该属性新的getValue()和setValue()函数，将来在使用Person的name属性时，实际访问的是该类中的代理。 //代理属性 val per = Person(&quot;Jake&quot;) println(per.name) per.name = &quot;haha&quot; println(per.name) 输出： admin_Jake admin_haha 很多同学可能会纳闷，输出结果中可以看出一直使用的是PrefixName中的返回的属性，那Person中定义的name成员有什么意义，不能直接操作吗？ 其实，Person中是没有name属性的，定义语句只是Kotlin中的语法格式罢了。不信？我们反编译字节码，看看Java代码中到底有些什么东西。 反编译为Java代码： 虽然Java代码里存在setter和getter方法，但是并没有name属性。也就是说我们的猜想是没有错的，Person中的name属性被代理后，实际Person类中并不存在该属性，从而替代它的是代理对象。 无论是Person中的setter还是getter，实际调用的都是代理对象中setValue，getValue ，不妨看下反编译后的代理属性类是什么样子的： 发现除了我们自己写的代码外，只多了几行检查参数的代码，也就是说Kotlin强制要求代理属性里的参setValue()\getValue()参数数必须不为null，如果参数为null，则抛出异常。 注意：被定义为代理的属性，该类中实际是不存在的 理解这句话，不要被Kotlin的语法所迷惑。 标准委托属性我们除了可以自定义委托属性外，Kotlin也为我们提供了集中常用的委托属性。 1、延迟属性lazy() 该委托可以保证属性在使用是才被初始化出来 例如： val str: String by lazy { &quot;abc&quot; } 定义时，在lazy后面的Lambda表达式进行初始化操作即可。细心的朋友也已经注意到lazy其实就是一个接收函数的函数（可以直接传递Lambda表达式）。 貌似有点不对啊，委托属性by关键字之后写的对象类，不是应该提供setValue()\getValue()函数吗？那么我们不妨继续看下lazy()函数，发现其返回的是Lazy的一个对象。 然而Lazy是个接口，那么实际SynchronizedLazyImpl应该是Lazy中的子类对象，那么这个子类对象有setValue（）\getValue()函数吗 我们发现子类对象，也没有这两个函数，这不科学啊，不满足定义一个委托属性的规则啊。先别急，别忘了，Kotlin中有个神奇的特性：扩展函数。 原来Lazy的getValue()是通过扩展函数实现的，那么setValue()呢？很遗憾，并没有，也就是说lazy委托只能给只读属性（val）使用：使用时初始化，初始化之后不能再进行赋值（当然你可以手动给Lazy添加一个扩展setValue()函数，但是如果这样便曲解了lazy委托的意义）。 既然这样，我们不妨在看看lazy是怎么实现的，其实让我们自己实现也完全没问题吧。 继续看实际的Lazy实现类 SynchronizedLazyImpl类， 注意里面的value属性的getter()函数，扩展的getValue()函数返回的就是这个属性。 使用起来也跟普通的属性没有任何区别 //...没使用前是不会被初始化的 println(str) //输出：abc 如果该属性需要多线程访问，为了保证线程安全，lazy()函数提供了两个参数的重载函数： //多线程安全 val str2: String by lazy(LazyThreadSafetyMode.PUBLICATION) { &quot;bcd&quot; } 2、可观察属性Delegates.observable() 有点类似于观察者设计模式，当属性值发生改变时，发出事件并做出响应事件。 怎么用呢？ class Person() { var name: String by PrefixName() var age: Int by Delegates.observable(0, { property, oldValue, newValue -&gt; println(&quot;属性名：${property.name} , 旧值：$oldValue , 新值：$newValue&quot;) }) constructor(name: String) : this() { this.name = name } } 我们为Person类添加一个age属性，该属性使用了可观察委托，第一个参数是属性初始值，一但属性值发生改变，第二个参数里的Lambda（函数）就会被调用。 调用： per.age = 10 输出： 属性名：age , 旧值：0 , 新值：10 那么底层的实现代码过程就不带大家看了，套路是一样，by之后的对象类提供setValue()\getValue()函数，贴出主要部分，具体的实现感兴趣的同学按照这个套路看源码即可，不难~ 3、Map存储属性map 该委托用于将map中存储的属性读取到Mode中，Kotlin官方考虑到如果存在一个Map集合，并且该集合的键值对对应Mode中的属性，那么可以使用该委托（实用性有待考察）。 这个就不讲了，个人感觉有点鸡肋，Json解析有各种解析工具（Gson、fastjson等），可能是个人使用场景使用不到吧，上一个官方demo结束。 class User(val map: Map&lt;String, Any?&gt;) { val name: String by map val age: Int by map } 在这个例子中，构造函数接受一个 map : val user = User(mapOf( &quot;name&quot; to &quot;John Doe&quot;, &quot;age&quot; to 25 )) var 属性可以用 MutableMap 代替只读的 Map： class MutableUser(val map: MutableMap&lt;String, Any?&gt;) { var name: String by map var age: Int by map } 总结除了了解常用的委托外，最主要的还是理解一个委托它究竟做了什么，怎么实现的？哪里不明白，反编译看Java源码可能会更直接，不得不承认Kotlin的语法糖太多，有些地方真的阅读起来比较晦涩，不过没事，谁让咱们懂Java。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Class类]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Class%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 类的定义Kotlin中的类也是使用class关键字定义 但整个类结构与Java有所不同：Kotlin中类的定义主要由三部分组成：类名、类头、类主体。 // 类名 类头 class Person(var name: String) { //...类主体 } 一、类名同Java紧跟class关键字之后，空格隔开 二、类头两部分组成： 成员属性 主构造函数 代码示例： class Person(var name: String) { init { println(&quot;属性已被初始化：$name&quot;) println(&quot;主构造额外操作&quot;) } } name是Person类的一个成员属性，小括号()是Person类的主构造方法。也就是说Kotlin中在创建Person类对象时，必须传入name属性值，并且会自动为其初始化，帮我们做了类似Java里this.name = name的操作。 如果我们的主构造除了初始化属性之外，还有别的代码操作，需要把这些操作放到init()函数中，Kotlin的主构造函数在初始化属性之后，会调用该函数。 调用： Person(&quot;Jack&quot;) 输出： 属性已被初始化：Jack 主构造额外操作 三、类主体类主体部分类似于Java（大括号里的东西），但也有所不同，前面的主构造额外函数init()也属于类主体区域内。 类主体可以包含： 构造函数和初始代码块 成员属性 成员函数 内部类 伴生对象 对象声明 1、构造函数除之前的主构造函数和init()函数外，Kotlin也支持多构造函数，其它的构造函数称为二级构造函数 constructor (name: String, age: Int) : this(name) { this.age = age } 这里，Kotlin定义二级构造函数与Java不同： 仅需constructor关键字修饰，不需要函数名 所有的二级构造必须先调用（代理）主构造，主构造执行完后，会执行二级构造中的代码 所以我们仅在二级构造中初始化了age属性，name属性已由之前的主构造初始化。 如果我们没有定义构造函数（主\二级），JVM虚拟机依旧会为我们提供一个无参构造函数，这和Java一样；但是，如果我们的主构造参数设置了默认值，Jvm虚拟机也会为我们提供一个无参构造。 //主构造存在默认参数，JVM依旧会提供一个无参构造 class Person(var name: String = &quot;无名&quot;) { //... ｝ 所以我们可以使用默认值直接创建Person对象 val wuMing = Person() （注：虽然我们已经创建过很多次对象了，但还是提下Kotlin创建对象是不需要new关键字的） 2、成员属性首先概念上是同Java的成员变量一样的，我们还是单独来说说它的区别和特点 Kotlin支持可变属性和只读属性，什么意思呢？类似于Java中常量和变量的概念 val关键字：只读属性，初始化后，只能访问，不能赋值 var关键字：可变属性，可读可写 getter()\setter() 讲到属性，不能少了JavaBean里的getter()\setter()方法，虽然Java的IDE基本都提供了自动生成代码的快捷选项，但Kotlin将其再一步简化 Kotlin中如果属性是var可变属性，那么默认就提供getter()\setter()函数，val则提供getter()函数 如果我们需要覆写这些getter()\setter()方法只需遵循以下格式： var &lt;propertyName&gt;: &lt;PropertyType&gt; [ = &lt;property_initializer&gt; ] &lt;getter&gt; &lt;setter&gt; 我们尝试修改age属性的getter()方法，不同年龄段，返回不同的数字： var age: Int = 0 get() { if (field &lt; 16) { return 0 } else if (field in 16..30) { return 1 } else return 2 } 调用： val per = Person(&quot;Jack&quot;, 10) println(per.age) //输出0 等等，getter()里的field是什么？备用字段 为什么我们不直接比较age而是用field关键字呢？ 因为在Kotlin中规定，如果直接使用属性名，那么就相当于调用它的getter()函数，所以如果我们在getter函数里直接使用age属性，那么这将是一个无限的递归，JVM自然会抛出 栈溢出。 为了解决这个问题Kotlin在getter()和setter()函数中为我们提供了这个备用字段field 3、成员函数在函数章节提到过，无论是定义，使用，作用域都同Java，暂一笔带过。 4、内部类Kotlin中对于内部类的定义有所不同，在Kotlin中内部类除了必须定义在类的内部外，还必须通过inner关键字修饰，否则它只是个嵌套类。 探讨内部类和嵌套类各自的特点： A是外部类，B是A的嵌套类，C是A的内部类，我们尝试互相访问对方的属性以及函数。 外部类访问嵌套类以及内部类中的资源，我们在A类中添加tell()函数测试： 以上代码中可以得出结论：外部类是无法直接访问嵌套类或者内部类中的任何资源 那么嵌套类能访问外部类资源吗？我们给嵌套类也加上tell()函数 很显然嵌套类是不能直接调用外部类资源以及内部类资源 再来看看内部类： Kotlin中的内部类跟Java一样是可以直接访问外部类资源，但不能访问嵌套类资源 最后，嵌套类、外部类是如何创建对象的: //嵌套类创建对象 val b = A.B() //内部类创建对象 val c =A().C() 嵌套类创建对象，需要指定外部类前缀；而内部类创建对象则需要通过外部类对象来创建 细心的朋友可能已经发现这两种书写格式在Java中很眼熟，内部类的创建格式与Java相同就不说了，这个嵌套类与Java的（static）静态内部类创建语法是一样的。 如果真如我们猜想的那样，Java中的静态内部类，可以访问直接外部类中static修饰的全局变量；Kotlin中的嵌套类我们不妨测试一下。（Kotlin中的全局变量通过伴生对象定义，这个之后会讲，先知道它就是全局变量即可） 我们发现嵌套类可以调用该变量 所以可以得出：Kotlin中的嵌套类的使用场景是类似与Java中的静态内部类的使用场景。 5、伴生对象前面也提到了Kotlin中是没有static关键字的，但是总得有东西来替代它，那么它就是伴生对象。 从名字来看它貌似是随着类一起出生的，它和Java中static的定义也很相似（当类加载时static修饰的属性和方法就直接加载到内存中）。 使用起来也和Java中是一样的，可以直接通过类名调用，还有伴生对象只能使用伴生对象中的属性及方法，就如同static修饰的方法只能调用static修饰的属性和方法一样。 6、对象声明与表达式单例设计模式大家一定再熟悉不过，如果在Java中，肯定首要是创建一个类，然后私有化构造方法等等，Kotlin中提供了更简便的实现方案。你不是仅需一个对象吗，那么干嘛要创建类，直接创建一个对象不是更好。 Kotlin中支持直接创建对象，称为：对象声明 ，使用object关键字修饰。 我们在之前的Person类中声明一个obj对象 那么这个对象对于Person来说就像一个全局的只读变量一样 当然你完全可以不用写在类的内部，只是要知道类的主体里可以写对象声明的 对象表达式又是什么？ Java中的匿名内部类，想必做android开发的同学再熟悉不过，那么Kotlin中的匿名内部类就叫做对象表达式。 既然类似Java中的匿名内部类，那么使用场景肯定也是类似的了。 这段代码想必大家都很熟悉，为Button设置点击事件的回调，用Java代码实现最直接的方法便是创建个匿名内部类对象，那么我们来看看Kotlin的对象表达式 我只能说实在是不能再像了（与Java匿名内部类相比）。 唯一的区别就在于，对象表达式可以直接访问局部作用域里的变量，不需要像java那样final修饰才行。 四、数据类最后再讲讲一种特殊的类：数据类 前面属性时，提到了JavaBean的概念，提供getter()和setter()函数，除了这两个函数之外equals()、toString()等也是几个常用函数，那么Kotlin中为了开发方便，直接提供data关键字来修饰这些数据类。 使用data修饰的类，除了之前var\val提供的setter()\getter()函数之外，还默认实现了 equals()/hashCode 函数 toString 格式是 &quot;User(name=john, age=42)&quot; [compontN()] copy() 函数 如果在类中明确声明或从基类继承了这些方法，编译器不会自动生成。 为确保这些生成代码的一致性，并实现有意义的行为，数据类要满足下面的要求： 主构造函数应该至少有一个参数； 主构造函数的所有参数必须标注为 val 或者 var ； 数据类不能是 abstract，open，sealed，或者 inner ； 在 JVM 中如果构造函数是无参的，则所有的属性必须有默认的值。 例如： data class Data(var data1: String, var data2: String)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Lambda]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 什么是Lambda表达式在函数的篇章里我们知道了Lambda表达式就是函数，并且也进行了证明。 这篇文章继续探讨Lambda的使用，以及书写规则 先来个最简单的，Lambda是函数，准确的来说是匿名函数 定义一个tell()函数，里面接收一个返回字符串的函数 /** * 函数名：tell * 参数：f * 参数类型：() 函数 * 参数函数的返回值：String * * 函数功能：打印传入函数返回的字符串 * */ fun tell(f: () -&gt; String){ println(f()) } 不用Lambda表达式的调用方式 tell(fun(): String { return &quot;string&quot; }) 显然，fun():String 这些东西都是固定的写法，并且不利于阅读，我们实际关心的应该只是函数体里的东西，那么为了开发方便，Lambda表达式就诞生了 Lambda表达式调用： tell({ &quot;string&quot; }) 我们发现，不光前面的固定代码被去掉了，return也被省略掉了。Lambda表达式中规定：如果需要返回值，那么返回值写在代码块的最后一行即可 Kotlin中的进一步简化，Kotlin中规定如果一个函数仅只有一个函数类型的形参，当传入的是Lambda表达式时，该函数的()小括号可以省略不写。所以最后的代码： tell{ &quot;string&quot; } 那么我们加点难度，Lambda中添加参数呢？ fun tell2(f: (str: String) -&gt; String) { println(f(&quot;123&quot;)) } 我们给参数函数中增加了一个参数，也就是说传入的函数是一个需要参数的函数，Lambda表达式该怎么写呢： tell2 { &quot;string:$it&quot; } // 输出：string:123 这里的it在之前函数篇章也有提到过，代表的是当函数仅一个参数时，为了使用lambda表达式方便，Kotlin为我们创建的默认形参名。 一个参数用it,那多个参数呢，我们为形参中的函数再添加一个参数： /** * 参数函数中添加多个参数 * */ fun tell3(f: (str1: String, str2: String) -&gt; String) { println(f(&quot;123&quot;, &quot;abc&quot;)) } 现在怎么调用呢： tell3 { str1, str2 -&gt; &quot;string:$str1 and $str2&quot; } // 输出：string:123 and abc 也就是说，当Lambda表达式中出现多个参数时，我们需要明确的写出参数名，以逗号隔开，函数体和参数之间使用 -&gt; 箭头的形式进行隔开即可。 如果我的Lambda表达式仅使用了一个参数，另一个参数可以不写吗？是不可以的，但是你可以使用下划线来替代它的参数名 //只使用1个参数 tell3 { str1, _ -&gt; &quot;string:$str1&quot; } // 输出：string:123 Kotlin中Lambda表达式的使用就讲到这里，复杂的Lambda表达式万变不离其宗，如果有漏掉的内容之后更新补充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-函数]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 函数定义什么是函数…不用解释了吧… 函数范围Kotlin 中可以在文件顶级声明函数，这就意味者你不用像在Java一样创建一个类来持有函数。除了顶级函数，Kotlin 函数自然也可以声明为局部的，作为成员函数或扩展函数。 定义一个函数一个简单的方法定义： fun add(n1: Int, n2: Int): Int { return n1 + n2 } 基本格式： fun 函数名(形参1: 参数类型 , 形参2: 参数类型...) &lt;: 返回值类型&gt;{ 函数体... } fun关键字定义 参数变量与参数类型之间用冒号隔开，多个参数逗号隔开； 无返回值的话，返回值类型可以省略；否则紧跟函数()括号之后，冒号隔开 与Java不同点：1、形参可以设置默认值fun add(n1: Int = 0, n2: Int = 0, n3: Int = 0): Int { return n1 + n2 + n3 } 好处：优雅的实现了Java方法重载特性 我们可以直接这样调用代码 println(add(1, 2)) //输出：3 println(add(1, 2, 3)) //输出：6 不用像Java那样重写个方法，给某个参数传个默认值或者null了。 2、指定命名参数如果，我只想传入第1个参数和第3个参数呢？ Kotlin中提供了命名参数的形式，来传递指定的参数 println(add(1, n3 = 4)) //跳过第2个参数 我们可以直接指定形参变量名传递参数，从而准确的传递参数到对应形参上 3、Unit 无返回值同Java void一样，Kotlin提供Unit表示无返回值，只不过一般都省略不写 fun tell(str: String): Unit { println(str) } //Unit省略不写 fun tell(str: String) { println(str) } 4、可变参数类似java中的可变参数，通过vararg关键字修饰 fun addMore(vararg arr: Int): Int { var result = 0 for (num in arr) { result += num } return result } 调用 println(addMore(1,2,3,4,5)) //15 函数的调用同Java 函数分类1、单表达式函数当函数只返回单个表达式时，大括号可以省略并在 = 后面定义函数体 诺编译器能推断出表达式返回的数据类型，返回值类型也可以省略 上面的add方法，就可改为: fun add(n1: Int = 0, n2: Int = 0, n3: Int = 0) = n1 + n2 + n3 2、成员函数没什么好讲的，同Java定义在类成员上的函数 class Person{ fun tell(){ println(&quot;.......&quot;) } } 3、局部函数Kotlin支持函数中定义函数，内部函数可以访问外部函数的变量。 fun outFun(): Int { var n = 1 fun inFun(): Int { n += 1 return n } return inFun() } 局部函数有什么用？实现闭包 什么是闭包：函数内包含子函数，并最终return子函数。 4、中缀函数在运算符章节已经提到过，infix关键字修饰，这里不再细讲 5、泛型函数同Java不介绍了 fun sigletonArray&lt;T&gt;(item: T): Array&lt;T&gt; { return Array&lt;T&gt;(1, {item}) } 6、扩展函数在某些情况下，某个类缺少部分功能，Java中的做法可以通过继承去扩展功能，在Kotlin中可以直接通过扩展函数的形式来解决该问题。 //扩展函数,给Int类添加一个add()函数 fun Int.add(num: Int): Int { return this.plus(num) } 那么只要是个Int对象都可以调用该函数： val num :Int = 10 //调用我们自定义的扩展函数 println(num.add(1)) 进一步探讨，难道我们真的为Int类添加了一个成员函数？ 显然是不可能的，扩展函数只是Kotlin给出的一种给某个类增加功能时新的实现思路，开发人员不必再像Java一样去创建子类或者装饰类了。那它跟真正的类成员函数有什么区别吗? 我们还是通过例子探讨这个问题：我们创建Java的Person类和它的子类SuperMan来对比（是的，Kotlin语法支持直接对Java类扩展） //Java代码 public class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } --------------------------------------------- public class SuperMan extends Person { public SuperMan(String name) { super(name); } } 我们尝试给Person和SuperMan类分别扩展个tell()函数，打印自己的名字。 //Kotlin代码进行扩展 //Person类扩展tell fun Person.tell() { println(&quot;person:&quot; + name) } //SuperMan类扩展方法 fun SuperMan.tell(){ println(&quot;superman:&quot; + name) } 分别创建Person对象和SuperMan对象，调用该函数是没有任何问题的。 val per = Person(&quot;A&quot;) val superMan = SuperMan(&quot;B&quot;) per.tell() //输出 ： person:A superMan.tell() //输出： superman:B 到现在一切都是正常的，假设我们有以下函数： fun say(per: Person) { per.tell() } 通过say()方法我们调用tell()方法，由于SuperMan是Person的子类，所以也可以传递，我们再看看结果： say(per) //输出：person:A say(superMan) //输出：person:A What? 既然都调用的是Person扩展的tell()函数，我们明明传递的是子类对象啊。 所以从这里看出来扩展函数实际并没有真正的给类添加一个成员函数，自然也不会有父与子之间覆写的概念，只是一套机制罢了。 1、Kotlin中扩展函数是直接被静态解析的。 也就是说扩展函数在编译时期，传递的的参数类型就已经固定不能改变，它不像继承关系里的成员函数在程序运行时期还会推到出你到底是子类对象还是父类对象。 2、扩展函数只能添加功能，不能覆写功能。 如果Peron类中已有getName()，我们对它进行扩展是不行了。 //尝试通过扩展方法覆写Person的getName() fun Person.getName():String{ return &quot;------ $name&quot; } 虽然Kotlin语法不会报错，但是当我们调用getName()时，是不会有任何变化的 //尝试调用被扩展覆写的方法 println(per.getName()) //依旧输出：A 以上2点，就是扩展函数与实际成员函数的区别。 7、尾递归函数 什么是伪递归？ Kotlin 支持函数式编程的尾递归。这个允许一些算法可以通过循环而不是递归解决问题，从而避免栈溢出。 tailrec关键字 当函数被标记为 tailrec 时，编译器会优化递归，并用高效迅速的循环代替它。 举例：求阶乘 Java中递归如何求阶乘？ private static long factorial(int num) { if (num == 0 || num== 1) { return 1; } else { return num * factorial(num-1); } } 上面这个方法看似是没有问题的，并且我们输入一个较小的数，阶乘也是完全能算出来的，但当我们计算10000(或者更大)的数的阶乘，Java抛出了StackOverError(栈内存溢出)： Kotlin中呢？会有同样的问题吗？ fun factorial1(num: Int): Long { if (num == 1 || num == 0) { return 1 } else { return num * factorial1(num - 1) } } 改好后，继续求10000的阶乘，发现Kotlin中同Java一样抛出来栈溢出StackOverError 怎么解决？ Kotlin中提供tailrec关键字来解决递归嵌套层次过多导致的栈异常问题 tailrec关键字使用要求： 1、tailrec关键字修饰递归方法 2、递归函数内部调用自身之后，不能再有代码或者运算（上面的代码不满足这一条） 显然第一条很容易满足，但第二条之前的代码在调用自身后还有乘法运算和返回数据这两步，是不满足条件的，我们尝试多加一个参数，通过该参数的引用来获取返回值。 最终修改后的代码： tailrec fun factorial2(num: Int, end: Result) { if (num == 1 || num == 0) { return } else { end.value *= BigInteger.valueOf(num.toLong()) factorial2(num - 1, end) } } 创建了一个Result类，来接收最后的计算结果： /** * 该类用于接收最后伪递归返回的结果 */ class Result(var value: BigInteger = BigInteger.valueOf(1L)) 这时候，计算10000的阶乘，发现很快就给出了运行结果： 那么，tailrec关键字究竟是怎么做到的？我们的代码中依旧还是有嵌套调用自身这个方法N多次,为什么没有出现异常？ 前面已经提到，Kotlin发现如果是tailrec关键词修饰的函数，会将其递归替换为高效的循环。我们把编译后字节码文件反编译回来后，就会发现factorial2()函数的确被编译器用循环的形式重新实现了： 8、高阶函数 什么是高阶函数？ 高阶函数就是可以接受函数作为参数的函数。 函数作为参数？ 炸一听好像很神奇，我们还是通过Java代码和Kotlin代码的对比，来了解所谓的高阶函数 首先，大家不妨想一想我们在Java中是怎么传递函数的？ 传递不了？是的，Java的参数不支持函数（方法）类型，但实际开发中，比如Android中为了给一个Button设置onClick事件，通常我们会创建一个匿名内部类对象来传递这个onClick方法不是吗？ 也就是说Java是通过对象的形式来传递方法的，那我们开始写代码： 需求：创建一个按钮对象，该对象提供一个downClick()方法用来触发点击事件，事件的具体内容由调用者决定。 Java版： public class ButtonJ { public void downClick(OnClick click) { System.out.println(&quot;---start---&quot;); if (click != null) { click.onClick(); } System.out.println(&quot;---end---&quot;); } public interface OnClick { void onClick(); } } Kotlin版： class Button { fun downClick(click: () -&gt; Unit) { println(&quot;---start---&quot;) click() println(&quot;---end---&quot;) } } 调用： //java ButtonJ buttonJ = new ButtonJ(); //需要传个OnClick的子类对象，才能间接调用 buttonJ.downClick(new ButtonJ.OnClick() { @Override public void onClick() { System.out.println(&quot;Java按钮被点击&quot;); } }); //Kotlin val buttonK = ButtonK() //直接传方法 buttonK.downClick(fun() { println(&quot;Kotlin按钮被点击&quot;) }) 通过上面的比对代码，想必大家对Kotlin中高阶函数有个基本认识了吧。 注：Kotlin中如果参数只有一个，并且它是一个函数，那么可以直接写成下面这种形式： //省略写法 buttonK.downClick{ println(&quot;Kotlin按钮被点击2&quot;) } 那如果多个参数中有一个函数，又该怎么写？（假设点击事件需要个额外参数） /** * 添加了一个额外参数，并将参数传递给点击事件处理 * */ fun downClick(arg: Int, click: (Int) -&gt; Unit) { println(&quot;---start---&quot;) click(arg) println(&quot;---end---&quot;) } 也就是说，你只需要把传递的函数定义为最后一个参数即可，调用如下: //增加额外参数 buttonK.downClick(666, fun(arg: Int) { println(&quot;这是你传入的参数：$arg&quot;) }) 总觉的这个fun关键字比较碍眼，能否简写？ 当然是可以的，简化后： buttonK.downClick(777, { println(&quot;这是你传入的参数：$it&quot;) }) 是不是很神奇？我们直接把fun和参数定义一起干掉了，编译器既然没报错，那么这是为什么？ 其实，我们在不经意间写了个Lambda表达式（{…}大括号里就是lambda表达式，it是Kotlin中为了开发人员访问参数而设置的默认的形参名，也就是我们实际传入的参数） Lambda表达式 什么是Lamdba表达式？ 其实Lambda表达式就是函数，并且我们在上面的代码中已经证明过了，不是吗？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-流程控制]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 流程控制语句if语句基本用法同Java 唯一不同点，Kotlin中没有三目运算符（a==xxx?b:c），取而代之的是if表达式 //Java String result = num % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;; //Kotlin val result = if (num % 2 ==0 ) &quot;偶数&quot; else &quot;奇数&quot; 注：if表达式是支持块级代码的，最后返回值由块级代码最后一行代码决定 val result = if (num % 2 == 0) { println(&quot;哈哈哈哈&quot;) &quot;偶数&quot; } else { println(&quot;啦啦啦啦&quot;) &quot;奇数&quot; } 所以，这样写也是没问题的。 When语句貌似是个新东西，其实是Java中switch语句的替代品 val num = 3 when(num){ 1 -&gt; println(&quot;num=1&quot;) 2 -&gt; println(&quot;num=2&quot;) 3 -&gt; println(&quot;num=3&quot;) 4,5,6 -&gt; println(&quot;num = 4 or 5 or 6&quot;) else -&gt; println(&quot;不认识这个数&quot;) } 乍一看，跟Java的switch语句的确没什么区别，只是换了一层皮。 那when到底强在哪？它可以作为表达式，我们把上面的代码改一改 val num = 3 val result = when (num) { 1 -&gt; &quot;num=1&quot; 2 -&gt; &quot;num=2&quot; 3 -&gt; &quot;num=3&quot; 4, 5, 6 -&gt; &quot;num = 4 or 5 or 6&quot; else -&gt; &quot;不认识这个数&quot; } println(result) 可以看到when语句是直接支持返回数据的。 这里要注意当when作为表达式时，一般是要求必须要有else来处理未知情况，但如果你的代码能显示的表明你已经考虑到了所有情况，else也是可以不写的。 当然它和if表达式一样支持块级代码，返回最后一行代码的值。 for循环Kotlin简化了for循环的使用，也就是说，你不用再顽固的写（i=0；i&lt;size;i++）这种东西了。 //获取item for (item: Int in arr) { println(item) } //获取索引 for (index in arr.indices) { println(arr[index]) } //即获取对象，又获取索引 for ((index, item) in arr.withIndex()) { println(&quot;$index :: $item&quot;) } 并且只要数据类型是支持迭代器的，那么都支持这种for循环形式 while 以及 do…while同Java一样 continue、break 以及 return基本使用方法同Java没有变 但是Kotlin支持标签跳转了，怎么玩呢？ 假设有一个三位数组arr[3][3][3]，每个大纬度里只存一个获奖数，需要我们拿程序找到它们，传统的java代码肯定是暴力循环，找到一个数后加标记，一层层跳回，直到返回最外层进行下一次循环，从而提高效率。然而Kotlin有了标签就不用这么麻烦了： var arr = arrayOf( arrayOf(arrayOf(1, 2, 3), arrayOf(1, 88, 3), arrayOf(1, 2, 3)), arrayOf(arrayOf(1, 2, 3), arrayOf(1, 2, 3), arrayOf(1, 88, 3)), arrayOf(arrayOf(1, 88, 3), arrayOf(1, 2, 3), arrayOf(1, 2, 3)) ) loop@ for (item in arr) { for (item2 in item) { for (item3 in item2) { if (item3 == 88) { println(&quot;找到了：$item3&quot;) continue@loop } } } } 代码会输出3次“找到了88”，无论是continue还是break他们的语义是不变的 continue会跳转到标签所在位置的下一次循环 break会结束掉标签所在位置的循环 上面的代码用break实现，只需要把loop@标签放到第二层循环即可。 return呢？return支持标签返回吗？ 答案肯定是支持的，return多半在函数跳转中搭配标签使用，在函数篇章里我们再进行详细讲解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-基本类型&运算符]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 基本类型与运算符本章主要学习Kotlin为我们提供好的基本类型，以及它们之间的运算操作（主要讲解与Java不同的地方） 基本类型类似Java中基本数据类型，Kotlin对Java中8种基本数据类型都做了对应的封装类，我们看看哪些不同部分 1、数值类型进制：不支持8进制 Kotlin官网中说提供了6种数值类的基本类型 类型 位宽 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 ！！！What? Char既然不是数值类型？Char不是可以通过ASCII码直接转换成数值，然后进行运算吗？ 是的，Char在Kotlin中不能直接当作数值使用 2、字符类型//java代码 char c = &apos;a&apos;; System.out.println(c == 97); 也就是说上面的Java代码，在Kotlin里是会报错的，Why？ 查看官方这一章节时，并没有看到详细的解释这个问题 那么如果我就是想进行数值判断操作呢，那你必须手动调用toInt()方法才行 //kotlin val c: Char = &apos;a&apos; println(c.toInt() == 97) 那Kotlin中能否直接使用Char类型直接进行运算，很神奇，他既然能… 只是得到的结果类型与Java不同： System.out.println(c + 1); //java 返回 98 println(c + 1) //kotlin 返回 b java中 c+1 返回的是int类型，因为int（32位）大于char(16位)，所以精度由小转为大，最终为int型。 Kotlin中 Char类型由于不是直接当数值用，所以最后返回依旧是char型（…尼玛，我都不知道怎么解释，望高手赐教）。 3、布尔类型跟Java一样 4、类型推导Kotlin中对于定义的变量，如果能通过初始化的字面值推断出它的类型，那么定义变量时，可以省略声明类型的语句 //通过后面的1可以推导出是Int型数据，所以可以写成num2的形式 val num1 : Int = 1 val num2 = 2 5、数值类型装箱首先，Java中的装箱指，将基本数据类型转换为对应的引用数据类型（int -&gt; Integer）,Kotlin中并没有什么Integer等装箱后的类，那么Kotlin中数据类型装箱又指的是什么？ val num1：Int = 128 val num2: Int = num1 val num3: Int = num1 println(num2 == num3) //true println(num2 === num3) //true （ == 比较值是否相等 ， === 比较内存地址是否相等） 到现在为止，貌似一切都正常，赋值时是以内存地址的形式直接进行操作的，内存地址相同，里面的值自然相同。那么，我们稍微改动下： val num1: Int = 128 val num2: Int? = num1 val num3: Int? = num1 println(num2 == num3) //true println(num2 === num3) //false 我们在num2、num3的定义后面加上了？号，该符号表示当前定义的对象可以为null，显然Int类型只是用来存储数值的，null这种非数值类型的值需要支持，那么就需要装箱操作 装箱后的数据类型除了值之外，内存地值会重新开辟(官方用语：不保留特征)，所以当比较num2 === num3时返回的是false。 对于学习过Java的同学来说，我们可以这样理解，没加？号是java里的int，加上？号就成了java里的Integer (可能有同学在这里测试时使用了小于128的数字，导致===返回的也是true，这并不是Kotlin语言的问题，而是JVM虚拟机中维护着有符号整形常量池（-128,127），在这个范围里的数值都会直接使用常量池的内存地址，所以这个范围内的数值装箱后比较内存地址依旧是相等的，想更详细了解JVM中的常量池，可自行百度，点到为止（跑题了）。 6、高精度转型问题Java中精度低的数据赋值给精度高的数据是支持的（隐式转换） //java 支持 int numInt = 1; long numLong = numInt; 而Kotlin中不支持这种隐式转换形式的 如果你确定可以转换，需要你手动去显示的调用.toLong()进行转型 val numInt: Int = 1 val numLong: Long = numInt.toLong() Why? Kotlin不是更高效、更优雅吗？怎么连隐式转换都不支持 官方给出了解释，大概意思是： //如果Kotlin支持隐式转换会怎么样（伪代码，实际会报错） val a : Int？ = 1 val b : Long？ = a println(a == b) //false 为什么a==b会是false？前面说了Kotlin中的双等于是比较值是否相等，这句话说的并不严谨，其实Kotlin里的双等于在这里实际调用的是Java中Long中equals()方法，我们看看Java中Long方法的实现： 原来如果传入比较的参数不是Long类型，那么直接返回false，这样明显违反了我们对==号的定义（比较值是否相等），所以Kotlin认为这种情况是不对的，即禁止了隐式转换这个特性。 最后，每个数值类型都支持下面显示的类型转换： toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char 7、字符串类型（String）与Java相同的部分我们就不说了，说说不同处 1、支持索引访问 val str = &quot;abcdef&quot; println(str[0]) 2、支持索引了，当然支持直接遍历，索引遍历就不提了，你可以这样写：（类似Java里的迭代器for循环） for (c in str) { println(c) } 3、支持段落字符串，在java里字符串中换行必须使用\n或者\r\n，Kotlin直接提供了段落字符串的书写格式 val lines = &quot;&quot;&quot; line1 line2 line3 &quot;&quot;&quot; println(lines) 4、字符串模版（Java拼接字符串的繁琐想必大家都有体会吧） val a = 1 val b = 2.5 val c = true println(&quot;a=$a , b=$b , c=$c&quot;) 这里是直接打印对象，如果想打印对象里的属性或者方法的返回值，使用模版表达式即可： val s = &quot;123456&quot; println(&quot;size=${s.length}&quot;) 运算符Kotlin支持标准的算数运算表达式，并且这些运算符被声明为相应类的成员（函数）。 也就是说Kotlin不光支持算数运算符，并且为每种算数运算符都提供一个相应的函数，例如下面的代码： // plus就是 + 运算对应的函数 val num : Int = 10 println(num +1) println(num.plus(1)) 那么常用的运算符对应函数有哪些呢？ a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b), a.mod(b) (deprecated) a..b a.rangeTo(b) 其他的运算符函数，建议直接查看官网 值得注意的是Kotlin并没有向java那样提供一种特殊符号来表示位运算，取而代之的是一种名为中缀运算符的形式 //java 位运算符（有符号右移） System.out.println(2&gt;&gt;1); //Kotlin位运算符（有符号右移） println(2 shr 1) 位运算符对照表： shl(bits) – 有符号左移 (相当于 Java’s &lt;&lt;) shr(bits) – 有符号右移 (相当于 Java’s &gt;&gt;) ushr(bits) – 无符号右移 (相当于 Java’s &gt;&gt;&gt;) and(bits) – 按位与 or(bits) – 按位或 xor(bits) – 按位异或 inv(bits) – 按位翻转 中缀运算符究竟是什么？前面我们说普通的算数运算符都有对应的函数，那中缀运算符呢？ 其实，中缀运算符就是函数，一种特殊的函数，并且我们还可以自定义中缀符 满足以下条件的函数就可以使用中缀符调用： 它们是成员函数或者是扩展函数，只有一个参数，使用infix关键词进行标记 扩展函数，到函数里我们再进行讲解。 现在，我们尝试模拟一种坐标的数据类型，并且支持同类型之间添加操作，添加操作结果为对应x,y累加，例如： //伪代码 Point(1,2) add Point(2,2) 得到 Point（3，4） 开始创建这个类型： package com.ljb.blogs.base.point /** * 坐标数据类 */ data class Point(val x: Int, val y: Int) 是的，Kotlin定义一个数据类就是这么简单，初学者看到这里多多少少会有些蒙圈，没事我们后面再细讲。 数据类有了，为了满足累加功能，我们为它提供一个add()函数 /** * 累加方法，返回累加后的Potint */ fun add(other: Point): Point { return Point(this.x+ other.x , this.y+other.y) } 方法添加好后，我们测试也没有问题 val point1 = Point(1, 2) val point2 = Point(2, 2) val result = point1.add(point2) println(result) //输出：Point(3,4) 但是并不是我们想要的中缀运算符的形式，那我们还差什么？ infix关键词 加上infix关键词后，我们再试试 val point1 = Point(1, 2) val point2 = Point(2, 2) val result = point1 add point2 println(result) //输出：Point(3,4) 到这里，中缀运算符的由来也就介绍完了，贴上Point完整代码，或者在博客头部的GitHub地址里下载最新源码 package com.ljb.blogs.base.point /** * 坐标数据类 */ data class Point(val x: Int, val y: Int) { /** * 累加方法，返回累加后的Potint */ infix fun add(other: Point): Point { return Point(this.x + other.x, this.y + other.y) } override fun toString(): String { return &quot;Point($x, $y)&quot; } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Package]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Package%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs Package命名规则（同Java） 由小写字母、下划线、数字组成，必须由小写字母或者下划线开头 行业规范，同Java，例如：com.baidu.xxx 与Java不同 1、Kotlin中包名可以和实际的文件夹不一致 2、没有指定包名，属于没有名字的默认包上 3、如果有重名包可以使用 as 关键字设置别名 1、Kotlin中包名可以和实际的文件夹不一致这条很好理解，我们知道Java中包名和实际的文件目录是保持一致，如果不一致，编译器会报错并提醒你修改包名或者移动到正确的包下。那么在Kotlin中就没有这么严格的限制，包名和实际的物理地址是可以不一致的。 a包下，存在一个Java文件和Kotlin文件，如果我们手动将文件的package修改为 com.ljb.blogs.packages.b Java文件通不过编译，需要你修改包名或者移动到正确的包下 而Kotlin，编译器会友善的给个提醒找不到实际目录，当然你可以选择忽视 （注：虽然可以包名与目录不一致，但开发者们了解下即好，以前该怎么写还是怎么写） 2、没有指定包名，属于没有名字的默认包上这一条其实也好理解，Kotlin不声明包行吗？答案是行的 /** * 这是一个没有指定包名的Kotlin类 */ class DefaultKotlin{ fun tell(){ println(&quot;我是没有定义包名的DefaultKotlin&quot;) } } 上面这个DefaultKotlin类，把他放到任意包下是不会报错的，即便它没有指定包。 如何使用它呢？跟Java一样，通过import的关键字直接导入即可 package com.ljb.blogs.packages.b //包名和实际的文件目录可以不同 import DefaultKotlin fun main(args: Array&lt;String&gt;) { val def = DefaultKotlin() def.tell() } 3、如果有重名包可以使用 as 关键字设置别名在Java中，如果你要同时使用类名相同，包名不同的两个类，你必须明确的指定出你使用的是哪个包下的类（以包名.类名的形式声明，至少申明其中一个）。 我们在c包，和d包下都定义了Person的Java类 c包下： package com.ljb.blogs.packages.c; public class Person { public void tell(){ System.out.println(&quot;我来自c包&quot;); } } d包下： package com.ljb.blogs.packages.d; public class Person { public void tell(){ System.out.println(&quot;我来自d包&quot;); } } 那么Java中是这样使用： package com.ljb.blogs.packages.a; //包名和实际的文件目录必须相同 import com.ljb.blogs.packages.c.Person; /** * Package Java测试类 */ public class PackageJava { public static void main(String[] args){ //两个同名类，至少你得写一个完成包名的类来进行区分 Person c = new Person(); com.ljb.blogs.packages.d.Person d = new com.ljb.blogs.packages.d.Person(); c.tell(); d.tell(); } } 首先，Java的这种形式Kotlin也是支持的。 其次，Kotlin提供了一种更好的解决方案，让代码看起来更优雅，使用as关键字为包设置别名 package com.ljb.blogs.packages.b //包名和实际的文件目录可以不同 import com.ljb.blogs.packages.c.Person as CPerson //设置别名 import com.ljb.blogs.packages.d.Person as DPerson /** * Package Kotlin测试类 */ fun main(args: Array&lt;String&gt;) { val c = CPerson() val d = DPerson() c.tell() d.tell() } 细心的朋友可能已经发现，我们直接通过Kotlin代码，造了两个Java类的对象（Person），是的，你没猜错，Kotlin可以直接调用Java代码。 其他细节前面提到了improt关键字，跟Java一样都用于导入包，那么java中会默认导入java.lang包，Kotlin又导入哪些包呢？ Kotlin默认导入的包： – kotlin.* – kotlin.annotation.* – kotlin.collections.* – kotlin.comparisons.* (since 1.1) – kotlin.io.* – kotlin.ranges.* – kotlin.sequences.* – kotlin.text.* 根据平台的不同，导入的平台包： JVM: —- java.lang.* —- kotlin.jvm.* JS: —- kotlin.js.* 这些包都分别是什么，有什么用呢？其实看名字我们也能猜出部分包的功能（笔者暂时也没具体的研究这些包的功能，先一笔带过）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJava背压]]></title>
    <url>%2F2019%2F05%2F17%2FRxJava%E8%83%8C%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[RxJava1背压（Backpressure）背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。 异步环境下 不是操作符，是一种策略 如何解决？主动拉取 通过reques(n) ，需本身支持背压策略 例如： Observable.range() //支持 Observable.interval() //不支持 对于本身就不支持背压的Observable，可以根据实际业务情况使用以下方法来缓解该问题： sample 这个操作符简单理解就是每隔X时间发送里最近那个事件，其他的事件浪费掉； buffer 这个操作符简单理解就是把X时间内的事件打包发送; onBackpressurebuffer 把observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常); onBackpressureDrop 将observable发送的事件抛弃掉，直到subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。 注：onBackpressurebuffer，onBackpressureDrop可以响应下游观察者的request(n)方法了，也就是说，使用了这两种操作符，可以让原本不支持背压的Observable“支持”背压了。 如何区分Observable是否支持背压？rxjava1中没有确切的方法可以确切的方法进行区分，这也是rxjava1中的设计缺陷 RxJava2解决背压问题rxjava2源码层面上重新设计了架构，用于解决背压。 Flowable 支持背压 Observable 不支持背压 各自都有自己的一套几乎相同操作符，但不能混用。如果你有意识的使用流控，那么就用 Flowable ，否则就用 Obserable。 但他们之间支持想换转换 Flowable -&gt; Obserable , Obserable -&gt; Flowable.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo目录和常用命令]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo%E7%9B%AE%E5%BD%95%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[目录介绍 node_modules npm 文件缓存目录 scaffolds 文夹件下存放的是文章、页面模版 scource 文夹件下存放的是我们的资源文件 themes 文件下存放的是我们的主题文件 .gitignore git 忽略文件，设置提交文件时，哪些文件不提交 _config.yml 站点配置文件 package.json 站点版本，站点依赖文件 yarn.lock yarn.lock 文件由 Yarn 自动创建，并且完全通过 Yarn 进行操作。 常用命令$ hexo generate (hexo g) 生成静态文件 $ hexo server (hexo s) 启动本地服务 $ hexo deploy (hexo d) 提交到远程仓库 $ hexo new page &quot;xx&quot;(hexo n page) 创建页面 $ hexo new &quot;xx&quot; (hexo n &quot;&quot;) 创建文章 $ hexo d -g 生成静态并提交到远程仓库 $ hexo s -g 生成静态文件并启动本地预览 $ hexo clean 清除本地 public 文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-优点&缺点]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E6%A7%BD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 这篇不聊具体的知识点，仅聊聊kotlin在开发中好的地方，以及博主自认为不好的地方。 优点1、延迟加载（lazy） 初始化变量的时机被推迟到访问时，有了它真是方便了我们这些不注重内存效率的码农…(lazy具体的实现在委托章节已经进行了详细讲解，不妨点进去看看它是怎么实现的) //仅在被访问时，才会开辟10个元素大小的数组 val arr by lazy { Array(10, { i: Int -&gt; i}) } fun main(args: Array&lt;String&gt;) { arr.map { println(it) } } 仅当你调用数组arr时，该数组才会被初始化出来。 2、getter/setter 首先Kotlin中我们不需要想Java那样手动的添加getter、setter方法了，这些Kotlin已经为我们做好了 3、with()函数简化代码 /* * 通过with语句，可以直接将对象传入，省掉对象的声明 * 使用场景：当对一个变量要进行多次使用，并返回与该变量相关的结果 * */ fun alphabet4(): String { return with(StringBuilder()) { append(&quot;START\n&quot;) for (letter in &apos;A&apos;..&apos;Z&apos;) { append(letter) } append(&quot;\nEND&quot;) toString() } } 4、apply()函数简化代码 /** *apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象 * 使用场景：初始化变量，并对该变量域有操作时 */ fun alphabet5() = StringBuilder().apply { append(&quot;START\n&quot;) for (letter in &apos;A&apos;..&apos;Z&apos;) { append(letter) } append(&quot;\nEND&quot;) }.toString()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-委托]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 委托一、委托类什么是委托类？ 代理设计模式，在Java中实现一个简单的代理模式如下： //抽象功能 public interface Base { void doSome(); } //实际操作类 public class BaseImpl implements Base { @Override public void doSome() { System.out.println(&quot;java do some thing.&quot;); } } //代理类 public class BaseProxy implements Base { private Base impl; public BaseProxy(Base impl) { this.impl = impl; } @Override public void doSome() { impl.doSome(); } } Kotlin在语法上提供by关键字，所以实现以上代码，可以更简洁点： interface Base { fun doSome() } class BaseImpl : Base { override fun doSome() { println(&quot;do some thing...&quot;) } } class BaseProxy(val b: Base) : Base by b 当然，你可以在代理中扩展doSome函数，只需覆写它即可 class BaseProxy(val b: Base) : Base by b{ override fun doSome() { println(&quot;pre&quot;) b.doSome() println(&quot;next&quot;) } } 二、委托属性委托类并不是重点，主要看看委托属性。 什么是委托属性？ 就如同代理设计模式一样 在调用属性或者赋值属性值时，我们希望做些额外操作，Kotlin基本语法如下： val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; by 后面的表达式就是代理，因为get() set() 对应的属性会被 getValue() setValue() 方法代理。属性代理不需要任何接口的实现，但必须要提供 getValues() 函数(如果是 var 还需要 setValue())。 例如： class Person() { var name: String by PrefixName() constructor(name: String) : this() { this.name = name } } class PrefixName { private var proxyName: String = &quot;admin_&quot; operator fun getValue(person: Person, property: KProperty&lt;*&gt;): String { return &quot;admin_$proxyName&quot; } operator fun setValue(person: Person, property: KProperty&lt;*&gt;, s: String) { proxyName = s } } 我们将Person的name属性委托给了PrefixName类，该类提供了该属性新的getValue()和setValue()函数，将来在使用Person的name属性时，实际访问的是该类中的代理。 //代理属性 val per = Person(&quot;Jake&quot;) println(per.name) per.name = &quot;haha&quot; println(per.name) 输出： admin_Jake admin_haha 很多同学可能会纳闷，输出结果中可以看出一直使用的是PrefixName中的返回的属性，那Person中定义的name成员有什么意义，不能直接操作吗？ 其实，Person中是没有name属性的，定义语句只是Kotlin中的语法格式罢了。不信？我们反编译字节码，看看Java代码中到底有些什么东西。 反编译为Java代码： 虽然Java代码里存在setter和getter方法，但是并没有name属性。也就是说我们的猜想是没有错的，Person中的name属性被代理后，实际Person类中并不存在该属性，从而替代它的是代理对象。 无论是Person中的setter还是getter，实际调用的都是代理对象中setValue，getValue ，不妨看下反编译后的代理属性类是什么样子的： 发现除了我们自己写的代码外，只多了几行检查参数的代码，也就是说Kotlin强制要求代理属性里的参setValue()\getValue()参数数必须不为null，如果参数为null，则抛出异常。 注意：被定义为代理的属性，该类中实际是不存在的 理解这句话，不要被Kotlin的语法所迷惑。 标准委托属性我们除了可以自定义委托属性外，Kotlin也为我们提供了集中常用的委托属性。 1、延迟属性lazy() 该委托可以保证属性在使用是才被初始化出来 例如： val str: String by lazy { &quot;abc&quot; } 定义时，在lazy后面的Lambda表达式进行初始化操作即可。细心的朋友也已经注意到lazy其实就是一个接收函数的函数（可以直接传递Lambda表达式）。 貌似有点不对啊，委托属性by关键字之后写的对象类，不是应该提供setValue()\getValue()函数吗？那么我们不妨继续看下lazy()函数，发现其返回的是Lazy的一个对象。 然而Lazy是个接口，那么实际SynchronizedLazyImpl应该是Lazy中的子类对象，那么这个子类对象有setValue（）\getValue()函数吗 我们发现子类对象，也没有这两个函数，这不科学啊，不满足定义一个委托属性的规则啊。先别急，别忘了，Kotlin中有个神奇的特性：扩展函数。 原来Lazy的getValue()是通过扩展函数实现的，那么setValue()呢？很遗憾，并没有，也就是说lazy委托只能给只读属性（val）使用：使用时初始化，初始化之后不能再进行赋值（当然你可以手动给Lazy添加一个扩展setValue()函数，但是如果这样便曲解了lazy委托的意义）。 既然这样，我们不妨在看看lazy是怎么实现的，其实让我们自己实现也完全没问题吧。 继续看实际的Lazy实现类 SynchronizedLazyImpl类， 注意里面的value属性的getter()函数，扩展的getValue()函数返回的就是这个属性。 使用起来也跟普通的属性没有任何区别 //...没使用前是不会被初始化的 println(str) //输出：abc 如果该属性需要多线程访问，为了保证线程安全，lazy()函数提供了两个参数的重载函数： //多线程安全 val str2: String by lazy(LazyThreadSafetyMode.PUBLICATION) { &quot;bcd&quot; } 2、可观察属性Delegates.observable() 有点类似于观察者设计模式，当属性值发生改变时，发出事件并做出响应事件。 怎么用呢？ class Person() { var name: String by PrefixName() var age: Int by Delegates.observable(0, { property, oldValue, newValue -&gt; println(&quot;属性名：${property.name} , 旧值：$oldValue , 新值：$newValue&quot;) }) constructor(name: String) : this() { this.name = name } } 我们为Person类添加一个age属性，该属性使用了可观察委托，第一个参数是属性初始值，一但属性值发生改变，第二个参数里的Lambda（函数）就会被调用。 调用： per.age = 10 输出： 属性名：age , 旧值：0 , 新值：10 那么底层的实现代码过程就不带大家看了，套路是一样，by之后的对象类提供setValue()\getValue()函数，贴出主要部分，具体的实现感兴趣的同学按照这个套路看源码即可，不难~ 3、Map存储属性map 该委托用于将map中存储的属性读取到Mode中，Kotlin官方考虑到如果存在一个Map集合，并且该集合的键值对对应Mode中的属性，那么可以使用该委托（实用性有待考察）。 这个就不讲了，个人感觉有点鸡肋，Json解析有各种解析工具（Gson、fastjson等），可能是个人使用场景使用不到吧，上一个官方demo结束。 class User(val map: Map&lt;String, Any?&gt;) { val name: String by map val age: Int by map } 在这个例子中，构造函数接受一个 map : val user = User(mapOf( &quot;name&quot; to &quot;John Doe&quot;, &quot;age&quot; to 25 )) var 属性可以用 MutableMap 代替只读的 Map： class MutableUser(val map: MutableMap&lt;String, Any?&gt;) { var name: String by map var age: Int by map } 总结除了了解常用的委托外，最主要的还是理解一个委托它究竟做了什么，怎么实现的？哪里不明白，反编译看Java源码可能会更直接，不得不承认Kotlin的语法糖太多，有些地方真的阅读起来比较晦涩，不过没事，谁让咱们懂Java。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Class类]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Class%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 类的定义Kotlin中的类也是使用class关键字定义 但整个类结构与Java有所不同：Kotlin中类的定义主要由三部分组成：类名、类头、类主体。 // 类名 类头 class Person(var name: String) { //...类主体 } 一、类名同Java紧跟class关键字之后，空格隔开 二、类头两部分组成： 成员属性 主构造函数 代码示例： class Person(var name: String) { init { println(&quot;属性已被初始化：$name&quot;) println(&quot;主构造额外操作&quot;) } } name是Person类的一个成员属性，小括号()是Person类的主构造方法。也就是说Kotlin中在创建Person类对象时，必须传入name属性值，并且会自动为其初始化，帮我们做了类似Java里this.name = name的操作。 如果我们的主构造除了初始化属性之外，还有别的代码操作，需要把这些操作放到init()函数中，Kotlin的主构造函数在初始化属性之后，会调用该函数。 调用： Person(&quot;Jack&quot;) 输出： 属性已被初始化：Jack 主构造额外操作 三、类主体类主体部分类似于Java（大括号里的东西），但也有所不同，前面的主构造额外函数init()也属于类主体区域内。 类主体可以包含： 构造函数和初始代码块 成员属性 成员函数 内部类 伴生对象 对象声明 1、构造函数除之前的主构造函数和init()函数外，Kotlin也支持多构造函数，其它的构造函数称为二级构造函数 constructor (name: String, age: Int) : this(name) { this.age = age } 这里，Kotlin定义二级构造函数与Java不同： 仅需constructor关键字修饰，不需要函数名 所有的二级构造必须先调用（代理）主构造，主构造执行完后，会执行二级构造中的代码 所以我们仅在二级构造中初始化了age属性，name属性已由之前的主构造初始化。 如果我们没有定义构造函数（主\二级），JVM虚拟机依旧会为我们提供一个无参构造函数，这和Java一样；但是，如果我们的主构造参数设置了默认值，Jvm虚拟机也会为我们提供一个无参构造。 //主构造存在默认参数，JVM依旧会提供一个无参构造 class Person(var name: String = &quot;无名&quot;) { //... ｝ 所以我们可以使用默认值直接创建Person对象 val wuMing = Person() （注：虽然我们已经创建过很多次对象了，但还是提下Kotlin创建对象是不需要new关键字的） 2、成员属性首先概念上是同Java的成员变量一样的，我们还是单独来说说它的区别和特点 Kotlin支持可变属性和只读属性，什么意思呢？类似于Java中常量和变量的概念 val关键字：只读属性，初始化后，只能访问，不能赋值 var关键字：可变属性，可读可写 getter()\setter() 讲到属性，不能少了JavaBean里的getter()\setter()方法，虽然Java的IDE基本都提供了自动生成代码的快捷选项，但Kotlin将其再一步简化 Kotlin中如果属性是var可变属性，那么默认就提供getter()\setter()函数，val则提供getter()函数 如果我们需要覆写这些getter()\setter()方法只需遵循以下格式： var &lt;propertyName&gt;: &lt;PropertyType&gt; [ = &lt;property_initializer&gt; ] &lt;getter&gt; &lt;setter&gt; 我们尝试修改age属性的getter()方法，不同年龄段，返回不同的数字： var age: Int = 0 get() { if (field &lt; 16) { return 0 } else if (field in 16..30) { return 1 } else return 2 } 调用： val per = Person(&quot;Jack&quot;, 10) println(per.age) //输出0 等等，getter()里的field是什么？备用字段 为什么我们不直接比较age而是用field关键字呢？ 因为在Kotlin中规定，如果直接使用属性名，那么就相当于调用它的getter()函数，所以如果我们在getter函数里直接使用age属性，那么这将是一个无限的递归，JVM自然会抛出 栈溢出。 为了解决这个问题Kotlin在getter()和setter()函数中为我们提供了这个备用字段field 3、成员函数在函数章节提到过，无论是定义，使用，作用域都同Java，暂一笔带过。 4、内部类Kotlin中对于内部类的定义有所不同，在Kotlin中内部类除了必须定义在类的内部外，还必须通过inner关键字修饰，否则它只是个嵌套类。 探讨内部类和嵌套类各自的特点： A是外部类，B是A的嵌套类，C是A的内部类，我们尝试互相访问对方的属性以及函数。 外部类访问嵌套类以及内部类中的资源，我们在A类中添加tell()函数测试： 以上代码中可以得出结论：外部类是无法直接访问嵌套类或者内部类中的任何资源 那么嵌套类能访问外部类资源吗？我们给嵌套类也加上tell()函数 很显然嵌套类是不能直接调用外部类资源以及内部类资源 再来看看内部类： Kotlin中的内部类跟Java一样是可以直接访问外部类资源，但不能访问嵌套类资源 最后，嵌套类、外部类是如何创建对象的: //嵌套类创建对象 val b = A.B() //内部类创建对象 val c =A().C() 嵌套类创建对象，需要指定外部类前缀；而内部类创建对象则需要通过外部类对象来创建 细心的朋友可能已经发现这两种书写格式在Java中很眼熟，内部类的创建格式与Java相同就不说了，这个嵌套类与Java的（static）静态内部类创建语法是一样的。 如果真如我们猜想的那样，Java中的静态内部类，可以访问直接外部类中static修饰的全局变量；Kotlin中的嵌套类我们不妨测试一下。（Kotlin中的全局变量通过伴生对象定义，这个之后会讲，先知道它就是全局变量即可） 我们发现嵌套类可以调用该变量 所以可以得出：Kotlin中的嵌套类的使用场景是类似与Java中的静态内部类的使用场景。 5、伴生对象前面也提到了Kotlin中是没有static关键字的，但是总得有东西来替代它，那么它就是伴生对象。 从名字来看它貌似是随着类一起出生的，它和Java中static的定义也很相似（当类加载时static修饰的属性和方法就直接加载到内存中）。 使用起来也和Java中是一样的，可以直接通过类名调用，还有伴生对象只能使用伴生对象中的属性及方法，就如同static修饰的方法只能调用static修饰的属性和方法一样。 6、对象声明与表达式单例设计模式大家一定再熟悉不过，如果在Java中，肯定首要是创建一个类，然后私有化构造方法等等，Kotlin中提供了更简便的实现方案。你不是仅需一个对象吗，那么干嘛要创建类，直接创建一个对象不是更好。 Kotlin中支持直接创建对象，称为：对象声明 ，使用object关键字修饰。 我们在之前的Person类中声明一个obj对象 那么这个对象对于Person来说就像一个全局的只读变量一样 当然你完全可以不用写在类的内部，只是要知道类的主体里可以写对象声明的 对象表达式又是什么？ Java中的匿名内部类，想必做android开发的同学再熟悉不过，那么Kotlin中的匿名内部类就叫做对象表达式。 既然类似Java中的匿名内部类，那么使用场景肯定也是类似的了。 这段代码想必大家都很熟悉，为Button设置点击事件的回调，用Java代码实现最直接的方法便是创建个匿名内部类对象，那么我们来看看Kotlin的对象表达式 我只能说实在是不能再像了（与Java匿名内部类相比）。 唯一的区别就在于，对象表达式可以直接访问局部作用域里的变量，不需要像java那样final修饰才行。 四、数据类最后再讲讲一种特殊的类：数据类 前面属性时，提到了JavaBean的概念，提供getter()和setter()函数，除了这两个函数之外equals()、toString()等也是几个常用函数，那么Kotlin中为了开发方便，直接提供data关键字来修饰这些数据类。 使用data修饰的类，除了之前var\val提供的setter()\getter()函数之外，还默认实现了 equals()/hashCode 函数 toString 格式是 &quot;User(name=john, age=42)&quot; [compontN()] copy() 函数 如果在类中明确声明或从基类继承了这些方法，编译器不会自动生成。 为确保这些生成代码的一致性，并实现有意义的行为，数据类要满足下面的要求： 主构造函数应该至少有一个参数； 主构造函数的所有参数必须标注为 val 或者 var ； 数据类不能是 abstract，open，sealed，或者 inner ； 在 JVM 中如果构造函数是无参的，则所有的属性必须有默认的值。 例如： data class Data(var data1: String, var data2: String)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Lambda]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 什么是Lambda表达式在函数的篇章里我们知道了Lambda表达式就是函数，并且也进行了证明。 这篇文章继续探讨Lambda的使用，以及书写规则 先来个最简单的，Lambda是函数，准确的来说是匿名函数 定义一个tell()函数，里面接收一个返回字符串的函数 /** * 函数名：tell * 参数：f * 参数类型：() 函数 * 参数函数的返回值：String * * 函数功能：打印传入函数返回的字符串 * */ fun tell(f: () -&gt; String){ println(f()) } 不用Lambda表达式的调用方式 tell(fun(): String { return &quot;string&quot; }) 显然，fun():String 这些东西都是固定的写法，并且不利于阅读，我们实际关心的应该只是函数体里的东西，那么为了开发方便，Lambda表达式就诞生了 Lambda表达式调用： tell({ &quot;string&quot; }) 我们发现，不光前面的固定代码被去掉了，return也被省略掉了。Lambda表达式中规定：如果需要返回值，那么返回值写在代码块的最后一行即可 Kotlin中的进一步简化，Kotlin中规定如果一个函数仅只有一个函数类型的形参，当传入的是Lambda表达式时，该函数的()小括号可以省略不写。所以最后的代码： tell{ &quot;string&quot; } 那么我们加点难度，Lambda中添加参数呢？ fun tell2(f: (str: String) -&gt; String) { println(f(&quot;123&quot;)) } 我们给参数函数中增加了一个参数，也就是说传入的函数是一个需要参数的函数，Lambda表达式该怎么写呢： tell2 { &quot;string:$it&quot; } // 输出：string:123 这里的it在之前函数篇章也有提到过，代表的是当函数仅一个参数时，为了使用lambda表达式方便，Kotlin为我们创建的默认形参名。 一个参数用it,那多个参数呢，我们为形参中的函数再添加一个参数： /** * 参数函数中添加多个参数 * */ fun tell3(f: (str1: String, str2: String) -&gt; String) { println(f(&quot;123&quot;, &quot;abc&quot;)) } 现在怎么调用呢： tell3 { str1, str2 -&gt; &quot;string:$str1 and $str2&quot; } // 输出：string:123 and abc 也就是说，当Lambda表达式中出现多个参数时，我们需要明确的写出参数名，以逗号隔开，函数体和参数之间使用 -&gt; 箭头的形式进行隔开即可。 如果我的Lambda表达式仅使用了一个参数，另一个参数可以不写吗？是不可以的，但是你可以使用下划线来替代它的参数名 //只使用1个参数 tell3 { str1, _ -&gt; &quot;string:$str1&quot; } // 输出：string:123 Kotlin中Lambda表达式的使用就讲到这里，复杂的Lambda表达式万变不离其宗，如果有漏掉的内容之后更新补充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-函数]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 函数定义什么是函数…不用解释了吧… 函数范围Kotlin 中可以在文件顶级声明函数，这就意味者你不用像在Java一样创建一个类来持有函数。除了顶级函数，Kotlin 函数自然也可以声明为局部的，作为成员函数或扩展函数。 定义一个函数一个简单的方法定义： fun add(n1: Int, n2: Int): Int { return n1 + n2 } 基本格式： fun 函数名(形参1: 参数类型 , 形参2: 参数类型...) &lt;: 返回值类型&gt;{ 函数体... } fun关键字定义 参数变量与参数类型之间用冒号隔开，多个参数逗号隔开； 无返回值的话，返回值类型可以省略；否则紧跟函数()括号之后，冒号隔开 与Java不同点：1、形参可以设置默认值fun add(n1: Int = 0, n2: Int = 0, n3: Int = 0): Int { return n1 + n2 + n3 } 好处：优雅的实现了Java方法重载特性 我们可以直接这样调用代码 println(add(1, 2)) //输出：3 println(add(1, 2, 3)) //输出：6 不用像Java那样重写个方法，给某个参数传个默认值或者null了。 2、指定命名参数如果，我只想传入第1个参数和第3个参数呢？ Kotlin中提供了命名参数的形式，来传递指定的参数 println(add(1, n3 = 4)) //跳过第2个参数 我们可以直接指定形参变量名传递参数，从而准确的传递参数到对应形参上 3、Unit 无返回值同Java void一样，Kotlin提供Unit表示无返回值，只不过一般都省略不写 fun tell(str: String): Unit { println(str) } //Unit省略不写 fun tell(str: String) { println(str) } 4、可变参数类似java中的可变参数，通过vararg关键字修饰 fun addMore(vararg arr: Int): Int { var result = 0 for (num in arr) { result += num } return result } 调用 println(addMore(1,2,3,4,5)) //15 函数的调用同Java 函数分类1、单表达式函数当函数只返回单个表达式时，大括号可以省略并在 = 后面定义函数体 诺编译器能推断出表达式返回的数据类型，返回值类型也可以省略 上面的add方法，就可改为: fun add(n1: Int = 0, n2: Int = 0, n3: Int = 0) = n1 + n2 + n3 2、成员函数没什么好讲的，同Java定义在类成员上的函数 class Person{ fun tell(){ println(&quot;.......&quot;) } } 3、局部函数Kotlin支持函数中定义函数，内部函数可以访问外部函数的变量。 fun outFun(): Int { var n = 1 fun inFun(): Int { n += 1 return n } return inFun() } 局部函数有什么用？实现闭包 什么是闭包：函数内包含子函数，并最终return子函数。 4、中缀函数在运算符章节已经提到过，infix关键字修饰，这里不再细讲 5、泛型函数同Java不介绍了 fun sigletonArray&lt;T&gt;(item: T): Array&lt;T&gt; { return Array&lt;T&gt;(1, {item}) } 6、扩展函数在某些情况下，某个类缺少部分功能，Java中的做法可以通过继承去扩展功能，在Kotlin中可以直接通过扩展函数的形式来解决该问题。 //扩展函数,给Int类添加一个add()函数 fun Int.add(num: Int): Int { return this.plus(num) } 那么只要是个Int对象都可以调用该函数： val num :Int = 10 //调用我们自定义的扩展函数 println(num.add(1)) 进一步探讨，难道我们真的为Int类添加了一个成员函数？ 显然是不可能的，扩展函数只是Kotlin给出的一种给某个类增加功能时新的实现思路，开发人员不必再像Java一样去创建子类或者装饰类了。那它跟真正的类成员函数有什么区别吗? 我们还是通过例子探讨这个问题：我们创建Java的Person类和它的子类SuperMan来对比（是的，Kotlin语法支持直接对Java类扩展） //Java代码 public class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } --------------------------------------------- public class SuperMan extends Person { public SuperMan(String name) { super(name); } } 我们尝试给Person和SuperMan类分别扩展个tell()函数，打印自己的名字。 //Kotlin代码进行扩展 //Person类扩展tell fun Person.tell() { println(&quot;person:&quot; + name) } //SuperMan类扩展方法 fun SuperMan.tell(){ println(&quot;superman:&quot; + name) } 分别创建Person对象和SuperMan对象，调用该函数是没有任何问题的。 val per = Person(&quot;A&quot;) val superMan = SuperMan(&quot;B&quot;) per.tell() //输出 ： person:A superMan.tell() //输出： superman:B 到现在一切都是正常的，假设我们有以下函数： fun say(per: Person) { per.tell() } 通过say()方法我们调用tell()方法，由于SuperMan是Person的子类，所以也可以传递，我们再看看结果： say(per) //输出：person:A say(superMan) //输出：person:A What? 既然都调用的是Person扩展的tell()函数，我们明明传递的是子类对象啊。 所以从这里看出来扩展函数实际并没有真正的给类添加一个成员函数，自然也不会有父与子之间覆写的概念，只是一套机制罢了。 1、Kotlin中扩展函数是直接被静态解析的。 也就是说扩展函数在编译时期，传递的的参数类型就已经固定不能改变，它不像继承关系里的成员函数在程序运行时期还会推到出你到底是子类对象还是父类对象。 2、扩展函数只能添加功能，不能覆写功能。 如果Peron类中已有getName()，我们对它进行扩展是不行了。 //尝试通过扩展方法覆写Person的getName() fun Person.getName():String{ return &quot;------ $name&quot; } 虽然Kotlin语法不会报错，但是当我们调用getName()时，是不会有任何变化的 //尝试调用被扩展覆写的方法 println(per.getName()) //依旧输出：A 以上2点，就是扩展函数与实际成员函数的区别。 7、尾递归函数 什么是伪递归？ Kotlin 支持函数式编程的尾递归。这个允许一些算法可以通过循环而不是递归解决问题，从而避免栈溢出。 tailrec关键字 当函数被标记为 tailrec 时，编译器会优化递归，并用高效迅速的循环代替它。 举例：求阶乘 Java中递归如何求阶乘？ private static long factorial(int num) { if (num == 0 || num== 1) { return 1; } else { return num * factorial(num-1); } } 上面这个方法看似是没有问题的，并且我们输入一个较小的数，阶乘也是完全能算出来的，但当我们计算10000(或者更大)的数的阶乘，Java抛出了StackOverError(栈内存溢出)： Kotlin中呢？会有同样的问题吗？ fun factorial1(num: Int): Long { if (num == 1 || num == 0) { return 1 } else { return num * factorial1(num - 1) } } 改好后，继续求10000的阶乘，发现Kotlin中同Java一样抛出来栈溢出StackOverError 怎么解决？ Kotlin中提供tailrec关键字来解决递归嵌套层次过多导致的栈异常问题 tailrec关键字使用要求： 1、tailrec关键字修饰递归方法 2、递归函数内部调用自身之后，不能再有代码或者运算（上面的代码不满足这一条） 显然第一条很容易满足，但第二条之前的代码在调用自身后还有乘法运算和返回数据这两步，是不满足条件的，我们尝试多加一个参数，通过该参数的引用来获取返回值。 最终修改后的代码： tailrec fun factorial2(num: Int, end: Result) { if (num == 1 || num == 0) { return } else { end.value *= BigInteger.valueOf(num.toLong()) factorial2(num - 1, end) } } 创建了一个Result类，来接收最后的计算结果： /** * 该类用于接收最后伪递归返回的结果 */ class Result(var value: BigInteger = BigInteger.valueOf(1L)) 这时候，计算10000的阶乘，发现很快就给出了运行结果： 那么，tailrec关键字究竟是怎么做到的？我们的代码中依旧还是有嵌套调用自身这个方法N多次,为什么没有出现异常？ 前面已经提到，Kotlin发现如果是tailrec关键词修饰的函数，会将其递归替换为高效的循环。我们把编译后字节码文件反编译回来后，就会发现factorial2()函数的确被编译器用循环的形式重新实现了： 8、高阶函数 什么是高阶函数？ 高阶函数就是可以接受函数作为参数的函数。 函数作为参数？ 炸一听好像很神奇，我们还是通过Java代码和Kotlin代码的对比，来了解所谓的高阶函数 首先，大家不妨想一想我们在Java中是怎么传递函数的？ 传递不了？是的，Java的参数不支持函数（方法）类型，但实际开发中，比如Android中为了给一个Button设置onClick事件，通常我们会创建一个匿名内部类对象来传递这个onClick方法不是吗？ 也就是说Java是通过对象的形式来传递方法的，那我们开始写代码： 需求：创建一个按钮对象，该对象提供一个downClick()方法用来触发点击事件，事件的具体内容由调用者决定。 Java版： public class ButtonJ { public void downClick(OnClick click) { System.out.println(&quot;---start---&quot;); if (click != null) { click.onClick(); } System.out.println(&quot;---end---&quot;); } public interface OnClick { void onClick(); } } Kotlin版： class Button { fun downClick(click: () -&gt; Unit) { println(&quot;---start---&quot;) click() println(&quot;---end---&quot;) } } 调用： //java ButtonJ buttonJ = new ButtonJ(); //需要传个OnClick的子类对象，才能间接调用 buttonJ.downClick(new ButtonJ.OnClick() { @Override public void onClick() { System.out.println(&quot;Java按钮被点击&quot;); } }); //Kotlin val buttonK = ButtonK() //直接传方法 buttonK.downClick(fun() { println(&quot;Kotlin按钮被点击&quot;) }) 通过上面的比对代码，想必大家对Kotlin中高阶函数有个基本认识了吧。 注：Kotlin中如果参数只有一个，并且它是一个函数，那么可以直接写成下面这种形式： //省略写法 buttonK.downClick{ println(&quot;Kotlin按钮被点击2&quot;) } 那如果多个参数中有一个函数，又该怎么写？（假设点击事件需要个额外参数） /** * 添加了一个额外参数，并将参数传递给点击事件处理 * */ fun downClick(arg: Int, click: (Int) -&gt; Unit) { println(&quot;---start---&quot;) click(arg) println(&quot;---end---&quot;) } 也就是说，你只需要把传递的函数定义为最后一个参数即可，调用如下: //增加额外参数 buttonK.downClick(666, fun(arg: Int) { println(&quot;这是你传入的参数：$arg&quot;) }) 总觉的这个fun关键字比较碍眼，能否简写？ 当然是可以的，简化后： buttonK.downClick(777, { println(&quot;这是你传入的参数：$it&quot;) }) 是不是很神奇？我们直接把fun和参数定义一起干掉了，编译器既然没报错，那么这是为什么？ 其实，我们在不经意间写了个Lambda表达式（{…}大括号里就是lambda表达式，it是Kotlin中为了开发人员访问参数而设置的默认的形参名，也就是我们实际传入的参数） Lambda表达式 什么是Lamdba表达式？ 其实Lambda表达式就是函数，并且我们在上面的代码中已经证明过了，不是吗？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-流程控制]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 流程控制语句if语句基本用法同Java 唯一不同点，Kotlin中没有三目运算符（a==xxx?b:c），取而代之的是if表达式 //Java String result = num % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;; //Kotlin val result = if (num % 2 ==0 ) &quot;偶数&quot; else &quot;奇数&quot; 注：if表达式是支持块级代码的，最后返回值由块级代码最后一行代码决定 val result = if (num % 2 == 0) { println(&quot;哈哈哈哈&quot;) &quot;偶数&quot; } else { println(&quot;啦啦啦啦&quot;) &quot;奇数&quot; } 所以，这样写也是没问题的。 When语句貌似是个新东西，其实是Java中switch语句的替代品 val num = 3 when(num){ 1 -&gt; println(&quot;num=1&quot;) 2 -&gt; println(&quot;num=2&quot;) 3 -&gt; println(&quot;num=3&quot;) 4,5,6 -&gt; println(&quot;num = 4 or 5 or 6&quot;) else -&gt; println(&quot;不认识这个数&quot;) } 乍一看，跟Java的switch语句的确没什么区别，只是换了一层皮。 那when到底强在哪？它可以作为表达式，我们把上面的代码改一改 val num = 3 val result = when (num) { 1 -&gt; &quot;num=1&quot; 2 -&gt; &quot;num=2&quot; 3 -&gt; &quot;num=3&quot; 4, 5, 6 -&gt; &quot;num = 4 or 5 or 6&quot; else -&gt; &quot;不认识这个数&quot; } println(result) 可以看到when语句是直接支持返回数据的。 这里要注意当when作为表达式时，一般是要求必须要有else来处理未知情况，但如果你的代码能显示的表明你已经考虑到了所有情况，else也是可以不写的。 当然它和if表达式一样支持块级代码，返回最后一行代码的值。 for循环Kotlin简化了for循环的使用，也就是说，你不用再顽固的写（i=0；i&lt;size;i++）这种东西了。 //获取item for (item: Int in arr) { println(item) } //获取索引 for (index in arr.indices) { println(arr[index]) } //即获取对象，又获取索引 for ((index, item) in arr.withIndex()) { println(&quot;$index :: $item&quot;) } 并且只要数据类型是支持迭代器的，那么都支持这种for循环形式 while 以及 do…while同Java一样 continue、break 以及 return基本使用方法同Java没有变 但是Kotlin支持标签跳转了，怎么玩呢？ 假设有一个三位数组arr[3][3][3]，每个大纬度里只存一个获奖数，需要我们拿程序找到它们，传统的java代码肯定是暴力循环，找到一个数后加标记，一层层跳回，直到返回最外层进行下一次循环，从而提高效率。然而Kotlin有了标签就不用这么麻烦了： var arr = arrayOf( arrayOf(arrayOf(1, 2, 3), arrayOf(1, 88, 3), arrayOf(1, 2, 3)), arrayOf(arrayOf(1, 2, 3), arrayOf(1, 2, 3), arrayOf(1, 88, 3)), arrayOf(arrayOf(1, 88, 3), arrayOf(1, 2, 3), arrayOf(1, 2, 3)) ) loop@ for (item in arr) { for (item2 in item) { for (item3 in item2) { if (item3 == 88) { println(&quot;找到了：$item3&quot;) continue@loop } } } } 代码会输出3次“找到了88”，无论是continue还是break他们的语义是不变的 continue会跳转到标签所在位置的下一次循环 break会结束掉标签所在位置的循环 上面的代码用break实现，只需要把loop@标签放到第二层循环即可。 return呢？return支持标签返回吗？ 答案肯定是支持的，return多半在函数跳转中搭配标签使用，在函数篇章里我们再进行详细讲解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-基本类型&运算符]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs 基本类型与运算符本章主要学习Kotlin为我们提供好的基本类型，以及它们之间的运算操作（主要讲解与Java不同的地方） 基本类型类似Java中基本数据类型，Kotlin对Java中8种基本数据类型都做了对应的封装类，我们看看哪些不同部分 1、数值类型进制：不支持8进制 Kotlin官网中说提供了6种数值类的基本类型 类型 位宽 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 ！！！What? Char既然不是数值类型？Char不是可以通过ASCII码直接转换成数值，然后进行运算吗？ 是的，Char在Kotlin中不能直接当作数值使用 2、字符类型//java代码 char c = &apos;a&apos;; System.out.println(c == 97); 也就是说上面的Java代码，在Kotlin里是会报错的，Why？ 查看官方这一章节时，并没有看到详细的解释这个问题 那么如果我就是想进行数值判断操作呢，那你必须手动调用toInt()方法才行 //kotlin val c: Char = &apos;a&apos; println(c.toInt() == 97) 那Kotlin中能否直接使用Char类型直接进行运算，很神奇，他既然能… 只是得到的结果类型与Java不同： System.out.println(c + 1); //java 返回 98 println(c + 1) //kotlin 返回 b java中 c+1 返回的是int类型，因为int（32位）大于char(16位)，所以精度由小转为大，最终为int型。 Kotlin中 Char类型由于不是直接当数值用，所以最后返回依旧是char型（…尼玛，我都不知道怎么解释，望高手赐教）。 3、布尔类型跟Java一样 4、类型推导Kotlin中对于定义的变量，如果能通过初始化的字面值推断出它的类型，那么定义变量时，可以省略声明类型的语句 //通过后面的1可以推导出是Int型数据，所以可以写成num2的形式 val num1 : Int = 1 val num2 = 2 5、数值类型装箱首先，Java中的装箱指，将基本数据类型转换为对应的引用数据类型（int -&gt; Integer）,Kotlin中并没有什么Integer等装箱后的类，那么Kotlin中数据类型装箱又指的是什么？ val num1：Int = 128 val num2: Int = num1 val num3: Int = num1 println(num2 == num3) //true println(num2 === num3) //true （ == 比较值是否相等 ， === 比较内存地址是否相等） 到现在为止，貌似一切都正常，赋值时是以内存地址的形式直接进行操作的，内存地址相同，里面的值自然相同。那么，我们稍微改动下： val num1: Int = 128 val num2: Int? = num1 val num3: Int? = num1 println(num2 == num3) //true println(num2 === num3) //false 我们在num2、num3的定义后面加上了？号，该符号表示当前定义的对象可以为null，显然Int类型只是用来存储数值的，null这种非数值类型的值需要支持，那么就需要装箱操作 装箱后的数据类型除了值之外，内存地值会重新开辟(官方用语：不保留特征)，所以当比较num2 === num3时返回的是false。 对于学习过Java的同学来说，我们可以这样理解，没加？号是java里的int，加上？号就成了java里的Integer (可能有同学在这里测试时使用了小于128的数字，导致===返回的也是true，这并不是Kotlin语言的问题，而是JVM虚拟机中维护着有符号整形常量池（-128,127），在这个范围里的数值都会直接使用常量池的内存地址，所以这个范围内的数值装箱后比较内存地址依旧是相等的，想更详细了解JVM中的常量池，可自行百度，点到为止（跑题了）。 6、高精度转型问题Java中精度低的数据赋值给精度高的数据是支持的（隐式转换） //java 支持 int numInt = 1; long numLong = numInt; 而Kotlin中不支持这种隐式转换形式的 如果你确定可以转换，需要你手动去显示的调用.toLong()进行转型 val numInt: Int = 1 val numLong: Long = numInt.toLong() Why? Kotlin不是更高效、更优雅吗？怎么连隐式转换都不支持 官方给出了解释，大概意思是： //如果Kotlin支持隐式转换会怎么样（伪代码，实际会报错） val a : Int？ = 1 val b : Long？ = a println(a == b) //false 为什么a==b会是false？前面说了Kotlin中的双等于是比较值是否相等，这句话说的并不严谨，其实Kotlin里的双等于在这里实际调用的是Java中Long中equals()方法，我们看看Java中Long方法的实现： 原来如果传入比较的参数不是Long类型，那么直接返回false，这样明显违反了我们对==号的定义（比较值是否相等），所以Kotlin认为这种情况是不对的，即禁止了隐式转换这个特性。 最后，每个数值类型都支持下面显示的类型转换： toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char 7、字符串类型（String）与Java相同的部分我们就不说了，说说不同处 1、支持索引访问 val str = &quot;abcdef&quot; println(str[0]) 2、支持索引了，当然支持直接遍历，索引遍历就不提了，你可以这样写：（类似Java里的迭代器for循环） for (c in str) { println(c) } 3、支持段落字符串，在java里字符串中换行必须使用\n或者\r\n，Kotlin直接提供了段落字符串的书写格式 val lines = &quot;&quot;&quot; line1 line2 line3 &quot;&quot;&quot; println(lines) 4、字符串模版（Java拼接字符串的繁琐想必大家都有体会吧） val a = 1 val b = 2.5 val c = true println(&quot;a=$a , b=$b , c=$c&quot;) 这里是直接打印对象，如果想打印对象里的属性或者方法的返回值，使用模版表达式即可： val s = &quot;123456&quot; println(&quot;size=${s.length}&quot;) 运算符Kotlin支持标准的算数运算表达式，并且这些运算符被声明为相应类的成员（函数）。 也就是说Kotlin不光支持算数运算符，并且为每种算数运算符都提供一个相应的函数，例如下面的代码： // plus就是 + 运算对应的函数 val num : Int = 10 println(num +1) println(num.plus(1)) 那么常用的运算符对应函数有哪些呢？ a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b), a.mod(b) (deprecated) a..b a.rangeTo(b) 其他的运算符函数，建议直接查看官网 值得注意的是Kotlin并没有向java那样提供一种特殊符号来表示位运算，取而代之的是一种名为中缀运算符的形式 //java 位运算符（有符号右移） System.out.println(2&gt;&gt;1); //Kotlin位运算符（有符号右移） println(2 shr 1) 位运算符对照表： shl(bits) – 有符号左移 (相当于 Java’s &lt;&lt;) shr(bits) – 有符号右移 (相当于 Java’s &gt;&gt;) ushr(bits) – 无符号右移 (相当于 Java’s &gt;&gt;&gt;) and(bits) – 按位与 or(bits) – 按位或 xor(bits) – 按位异或 inv(bits) – 按位翻转 中缀运算符究竟是什么？前面我们说普通的算数运算符都有对应的函数，那中缀运算符呢？ 其实，中缀运算符就是函数，一种特殊的函数，并且我们还可以自定义中缀符 满足以下条件的函数就可以使用中缀符调用： 它们是成员函数或者是扩展函数，只有一个参数，使用infix关键词进行标记 扩展函数，到函数里我们再进行讲解。 现在，我们尝试模拟一种坐标的数据类型，并且支持同类型之间添加操作，添加操作结果为对应x,y累加，例如： //伪代码 Point(1,2) add Point(2,2) 得到 Point（3，4） 开始创建这个类型： package com.ljb.blogs.base.point /** * 坐标数据类 */ data class Point(val x: Int, val y: Int) 是的，Kotlin定义一个数据类就是这么简单，初学者看到这里多多少少会有些蒙圈，没事我们后面再细讲。 数据类有了，为了满足累加功能，我们为它提供一个add()函数 /** * 累加方法，返回累加后的Potint */ fun add(other: Point): Point { return Point(this.x+ other.x , this.y+other.y) } 方法添加好后，我们测试也没有问题 val point1 = Point(1, 2) val point2 = Point(2, 2) val result = point1.add(point2) println(result) //输出：Point(3,4) 但是并不是我们想要的中缀运算符的形式，那我们还差什么？ infix关键词 加上infix关键词后，我们再试试 val point1 = Point(1, 2) val point2 = Point(2, 2) val result = point1 add point2 println(result) //输出：Point(3,4) 到这里，中缀运算符的由来也就介绍完了，贴上Point完整代码，或者在博客头部的GitHub地址里下载最新源码 package com.ljb.blogs.base.point /** * 坐标数据类 */ data class Point(val x: Int, val y: Int) { /** * 累加方法，返回累加后的Potint */ infix fun add(other: Point): Point { return Point(this.x + other.x, this.y + other.y) } override fun toString(): String { return &quot;Point($x, $y)&quot; } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-Android世界的一股清流-Package]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-Android%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81-Package%2F</url>
    <content type="text"><![CDATA[源码地址：https://github.com/cn-ljb/KotlinBlogs Package命名规则（同Java） 由小写字母、下划线、数字组成，必须由小写字母或者下划线开头 行业规范，同Java，例如：com.baidu.xxx 与Java不同 1、Kotlin中包名可以和实际的文件夹不一致 2、没有指定包名，属于没有名字的默认包上 3、如果有重名包可以使用 as 关键字设置别名 1、Kotlin中包名可以和实际的文件夹不一致这条很好理解，我们知道Java中包名和实际的文件目录是保持一致，如果不一致，编译器会报错并提醒你修改包名或者移动到正确的包下。那么在Kotlin中就没有这么严格的限制，包名和实际的物理地址是可以不一致的。 a包下，存在一个Java文件和Kotlin文件，如果我们手动将文件的package修改为 com.ljb.blogs.packages.b Java文件通不过编译，需要你修改包名或者移动到正确的包下 而Kotlin，编译器会友善的给个提醒找不到实际目录，当然你可以选择忽视 （注：虽然可以包名与目录不一致，但开发者们了解下即好，以前该怎么写还是怎么写） 2、没有指定包名，属于没有名字的默认包上这一条其实也好理解，Kotlin不声明包行吗？答案是行的 /** * 这是一个没有指定包名的Kotlin类 */ class DefaultKotlin{ fun tell(){ println(&quot;我是没有定义包名的DefaultKotlin&quot;) } } 上面这个DefaultKotlin类，把他放到任意包下是不会报错的，即便它没有指定包。 如何使用它呢？跟Java一样，通过import的关键字直接导入即可 package com.ljb.blogs.packages.b //包名和实际的文件目录可以不同 import DefaultKotlin fun main(args: Array&lt;String&gt;) { val def = DefaultKotlin() def.tell() } 3、如果有重名包可以使用 as 关键字设置别名在Java中，如果你要同时使用类名相同，包名不同的两个类，你必须明确的指定出你使用的是哪个包下的类（以包名.类名的形式声明，至少申明其中一个）。 我们在c包，和d包下都定义了Person的Java类 c包下： package com.ljb.blogs.packages.c; public class Person { public void tell(){ System.out.println(&quot;我来自c包&quot;); } } d包下： package com.ljb.blogs.packages.d; public class Person { public void tell(){ System.out.println(&quot;我来自d包&quot;); } } 那么Java中是这样使用： package com.ljb.blogs.packages.a; //包名和实际的文件目录必须相同 import com.ljb.blogs.packages.c.Person; /** * Package Java测试类 */ public class PackageJava { public static void main(String[] args){ //两个同名类，至少你得写一个完成包名的类来进行区分 Person c = new Person(); com.ljb.blogs.packages.d.Person d = new com.ljb.blogs.packages.d.Person(); c.tell(); d.tell(); } } 首先，Java的这种形式Kotlin也是支持的。 其次，Kotlin提供了一种更好的解决方案，让代码看起来更优雅，使用as关键字为包设置别名 package com.ljb.blogs.packages.b //包名和实际的文件目录可以不同 import com.ljb.blogs.packages.c.Person as CPerson //设置别名 import com.ljb.blogs.packages.d.Person as DPerson /** * Package Kotlin测试类 */ fun main(args: Array&lt;String&gt;) { val c = CPerson() val d = DPerson() c.tell() d.tell() } 细心的朋友可能已经发现，我们直接通过Kotlin代码，造了两个Java类的对象（Person），是的，你没猜错，Kotlin可以直接调用Java代码。 其他细节前面提到了improt关键字，跟Java一样都用于导入包，那么java中会默认导入java.lang包，Kotlin又导入哪些包呢？ Kotlin默认导入的包： – kotlin.* – kotlin.annotation.* – kotlin.collections.* – kotlin.comparisons.* (since 1.1) – kotlin.io.* – kotlin.ranges.* – kotlin.sequences.* – kotlin.text.* 根据平台的不同，导入的平台包： JVM: —- java.lang.* —- kotlin.jvm.* JS: —- kotlin.js.* 这些包都分别是什么，有什么用呢？其实看名字我们也能猜出部分包的功能（笔者暂时也没具体的研究这些包的功能，先一笔带过）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJava背压]]></title>
    <url>%2F2019%2F05%2F17%2FRxJava%E8%83%8C%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[RxJava1背压（Backpressure）背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。 异步环境下 不是操作符，是一种策略 如何解决？主动拉取 通过reques(n) ，需本身支持背压策略 例如： Observable.range() //支持 Observable.interval() //不支持 对于本身就不支持背压的Observable，可以根据实际业务情况使用以下方法来缓解该问题： sample 这个操作符简单理解就是每隔X时间发送里最近那个事件，其他的事件浪费掉； buffer 这个操作符简单理解就是把X时间内的事件打包发送; onBackpressurebuffer 把observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常); onBackpressureDrop 将observable发送的事件抛弃掉，直到subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。 注：onBackpressurebuffer，onBackpressureDrop可以响应下游观察者的request(n)方法了，也就是说，使用了这两种操作符，可以让原本不支持背压的Observable“支持”背压了。 如何区分Observable是否支持背压？rxjava1中没有确切的方法可以确切的方法进行区分，这也是rxjava1中的设计缺陷 RxJava2解决背压问题rxjava2源码层面上重新设计了架构，用于解决背压。 Flowable 支持背压 Observable 不支持背压 各自都有自己的一套几乎相同操作符，但不能混用。如果你有意识的使用流控，那么就用 Flowable ，否则就用 Obserable。 但他们之间支持想换转换 Flowable -&gt; Obserable , Obserable -&gt; Flowable.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo目录和常用命令]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo%E7%9B%AE%E5%BD%95%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[目录介绍 node_modules npm 文件缓存目录 scaffolds 文夹件下存放的是文章、页面模版 scource 文夹件下存放的是我们的资源文件 themes 文件下存放的是我们的主题文件 .gitignore git 忽略文件，设置提交文件时，哪些文件不提交 _config.yml 站点配置文件 package.json 站点版本，站点依赖文件 yarn.lock yarn.lock 文件由 Yarn 自动创建，并且完全通过 Yarn 进行操作。 常用命令$ hexo generate (hexo g) 生成静态文件 $ hexo server (hexo s) 启动本地服务 $ hexo deploy (hexo d) 提交到远程仓库 $ hexo new page &quot;xx&quot;(hexo n page) 创建页面 $ hexo new &quot;xx&quot; (hexo n &quot;&quot;) 创建文章 $ hexo d -g 生成静态并提交到远程仓库 $ hexo s -g 生成静态文件并启动本地预览 $ hexo clean 清除本地 public 文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
